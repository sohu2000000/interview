/*
 * ================================================================================
 * NVIDIA 面试题：32位无符号整数位反转 (Reverse Bits in 32-bit Unsigned Integer)
 * ================================================================================
 * 
 * 题目描述：
 * 给定一个32位无符号整数，反转其二进制位的顺序。
 * 
 * 例如：
 * 输入：43261596 (二进制：00000010100101000001111010011100)
 * 输出：964176192 (二进制：00111001011110000010100101000000)
 * 
 * 要求：
 * 1. 时间复杂度：O(1) 或 O(log n)
 * 2. 空间复杂度：O(1)
 * 3. 不使用额外的数组或字符串
 * 
 * 考察点：
 * - 位操作技巧
 * - 算法优化思维
 * - 二进制数理解
 * - 分治思想的应用
 * 
 * 解法思路：
 * 方法1：逐位反转（基础解法）
 * 方法2：分治法（高效解法）
 * 方法3：查表法（空间换时间）
 * ================================================================================
 */

#include <stdio.h>
#include <stdint.h>
#include <time.h>

/**
 * 方法1：逐位反转 - 基础解法
 * 时间复杂度：O(32) = O(1)
 * 空间复杂度：O(1)
 */
uint32_t reverse_bits_basic(uint32_t n) {
    uint32_t result = 0;
    
    // 逐位处理，共32位
    for (int i = 0; i < 32; i++) {
        // 将result左移1位，为新的位腾出空间
        result = (result << 1) | (n & 1);
        // 将n右移1位，准备处理下一位
        n >>= 1;
    }
    
    return result;
}

/**
 * 方法2：分治法 - 高效解法
 * 
 * 分治思路：
 * 将32位反转问题分解为更小的子问题，通过5个步骤完成：
 * - 32 = 2^5，所以需要5个步骤
 * - 每个步骤处理的位数是前一步的2倍：2位→4位→8位→16位→32位
 * 
 * 核心原理：
 * 如果我们能反转k位，那么我们就能反转2k位。通过递归构造，
 * 从最小的2位反转开始，逐步构建出32位反转的能力。
 * 
 * 时间复杂度：O(1) - 固定5步操作，无循环
 * 空间复杂度：O(1)
 * 
 * 示例演示（以8位为例便于理解）：
 * 原始: 10110100
 * 步骤1: 01111000 (交换相邻2位: 10→01, 11→11, 01→10, 00→00)
 * 步骤2: 10000111 (交换相邻4位: 0111→1000, 1000→0111)
 * 最终:   10000111 (完成8位反转)
 */
uint32_t reverse_bits_divide_conquer(uint32_t n) {
    /*
     * 步骤1：交换每相邻的2位
     * 
     * 原理：将位对(AB)变成(BA)
     * 例如：10110100 → 01111000
     *      AB CD EF GH → BA DC FE HG
     * 
     * 实现：
     * - 0x55555555 = 01010101... 选择奇数位(位置1,3,5,7...)
     * - 0xAAAAAAAA = 10101010... 选择偶数位(位置0,2,4,6...)
     * - 奇数位左移1位，偶数位右移1位，然后OR组合
     */
    n = ((n & 0x55555555) << 1) | ((n & 0xAAAAAAAA) >> 1);
    
    /*
     * 步骤2：交换每相邻的4位中的2位组
     * 
     * 原理：将4位组(ABCD)变成(CDAB)
     * 现在每个2位组已经内部反转了，我们要交换2位组的位置
     * 
     * 实现：
     * - 0x33333333 = 00110011... 选择每4位中的低2位
     * - 0xCCCCCCCC = 11001100... 选择每4位中的高2位
     * - 低2位左移2位，高2位右移2位
     */
    n = ((n & 0x33333333) << 2) | ((n & 0xCCCCCCCC) >> 2);
    
    /*
     * 步骤3：交换每相邻的8位中的4位组
     * 
     * 原理：将8位组(ABCDEFGH)变成(EFGHABCD)
     * 现在每个4位组已经内部反转了，我们要交换4位组的位置
     * 
     * 实现：
     * - 0x0F0F0F0F = 00001111... 选择每8位中的低4位
     * - 0xF0F0F0F0 = 11110000... 选择每8位中的高4位
     */
    n = ((n & 0x0F0F0F0F) << 4) | ((n & 0xF0F0F0F0) >> 4);
    
    /*
     * 步骤4：交换每相邻的16位中的8位组
     * 
     * 原理：将16位组变成内部反转的形式
     * 现在每个8位组已经内部反转了，我们要交换8位组的位置
     * 
     * 实现：
     * - 0x00FF00FF = 00000000111111110000000011111111
     * - 0xFF00FF00 = 11111111000000001111111100000000
     */
    n = ((n & 0x00FF00FF) << 8) | ((n & 0xFF00FF00) >> 8);
    
    /*
     * 步骤5：交换高16位和低16位
     * 
     * 原理：最后一步，交换整个32位数的高16位和低16位
     * 现在每个16位组已经内部反转了，最后交换它们的位置
     * 
     * 实现：
     * - 0x0000FFFF = 低16位掩码
     * - 0xFFFF0000 = 高16位掩码
     * - 低16位左移16位变成高16位，高16位右移16位变成低16位
     */
    n = ((n & 0x0000FFFF) << 16) | ((n & 0xFFFF0000) >> 16);
    
    /*
     * 完整的32位反转过程总结：
     * 
     * 1. 每相邻2位内部反转  → 所有2位组都反转了
     * 2. 每相邻4位的2位组交换 → 所有4位组都反转了  
     * 3. 每相邻8位的4位组交换 → 所有8位组都反转了
     * 4. 每相邻16位的8位组交换 → 所有16位组都反转了
     * 5. 高低16位交换 → 整个32位数反转完成
     * 
     * 这就是分治思想的精髓：通过解决小问题来解决大问题！
     */
    
    return n;
}

/**
 * 方法3：查表法 - 空间换时间
 * 预计算8位的反转表，然后组合
 * 时间复杂度：O(1)
 * 空间复杂度：O(256) - 查表空间
 */
uint32_t reverse_bits_lookup(uint32_t n) {
    // 8位反转查找表（0-255的反转值）
    static uint8_t lookup_table[256] = {0};
    static int table_initialized = 0;
    
    // 初始化查找表（只执行一次）
    if (!table_initialized) {
        for (int i = 0; i < 256; i++) {
            uint8_t reversed = 0;
            uint8_t num = i;
            for (int j = 0; j < 8; j++) {
                reversed = (reversed << 1) | (num & 1);
                num >>= 1;
            }
            lookup_table[i] = reversed;
        }
        table_initialized = 1;
    }
    
    // 将32位数分成4个8位段，分别查表后组合
    return (lookup_table[n & 0xFF] << 24) |
           (lookup_table[(n >> 8) & 0xFF] << 16) |
           (lookup_table[(n >> 16) & 0xFF] << 8) |
           (lookup_table[(n >> 24) & 0xFF]);
}

/**
 * 辅助函数：打印32位二进制表示
 */
void print_binary(uint32_t n, const char* label) {
    printf("%s: ", label);
    for (int i = 31; i >= 0; i--) {
        printf("%d", (n >> i) & 1);
        if (i % 4 == 0 && i > 0) printf(" ");  // 每4位加空格
    }
    printf(" (%u)\n", n);
}

/**
 * 演示分治算法的每个步骤
 * 帮助理解分治过程
 */
void demonstrate_divide_conquer_steps(uint32_t input) {
    printf("=== 分治算法步骤演示 ===\n");
    printf("输入数字: 0x%08X\n", input);
    
    uint32_t n = input;
    print_binary(n, "原始数据");
    
    // 步骤1：交换每相邻的2位
    n = ((n & 0x55555555) << 1) | ((n & 0xAAAAAAAA) >> 1);
    print_binary(n, "步骤1后");
    printf("        ↑ 每相邻2位内部交换 (AB→BA, CD→DC, ...)\n\n");
    
    // 步骤2：交换每相邻的4位中的2位组
    n = ((n & 0x33333333) << 2) | ((n & 0xCCCCCCCC) >> 2);
    print_binary(n, "步骤2后");
    printf("        ↑ 每4位组中的2位组交换 (ABCD→CDAB)\n\n");
    
    // 步骤3：交换每相邻的8位中的4位组
    n = ((n & 0x0F0F0F0F) << 4) | ((n & 0xF0F0F0F0) >> 4);
    print_binary(n, "步骤3后");
    printf("        ↑ 每8位组中的4位组交换 (ABCDEFGH→EFGHABCD)\n\n");
    
    // 步骤4：交换每相邻的16位中的8位组
    n = ((n & 0x00FF00FF) << 8) | ((n & 0xFF00FF00) >> 8);
    print_binary(n, "步骤4后");
    printf("        ↑ 每16位组中的8位组交换\n\n");
    
    // 步骤5：交换高16位和低16位
    n = ((n & 0x0000FFFF) << 16) | ((n & 0xFFFF0000) >> 16);
    print_binary(n, "最终结果");
    printf("        ↑ 高16位和低16位交换\n\n");
    
    // 验证结果
    uint32_t expected = reverse_bits_basic(input);
    if (n == expected) {
        printf("✓ 分治算法结果正确！\n");
    } else {
        printf("✗ 分治算法结果错误！期望: %u, 实际: %u\n", expected, n);
    }
    printf("\n");
}

/**
 * 测试函数
 */
void test_reverse_bits() {
    uint32_t test_cases[] = {
        43261596,    // 示例数据
        0,           // 边界情况：全0
        0xFFFFFFFF,  // 边界情况：全1
        1,           // 最小正数
        0x80000000,  // 最高位为1
        0x12345678,  // 常见测试数据
        0xAAAAAAAA,  // 交替位模式
        0x55555555   // 交替位模式
    };
    
    int num_tests = sizeof(test_cases) / sizeof(test_cases[0]);
    
    printf("=== 32位无符号整数位反转测试 ===\n\n");
    
    for (int i = 0; i < num_tests; i++) {
        uint32_t input = test_cases[i];
        uint32_t result1 = reverse_bits_basic(input);
        uint32_t result2 = reverse_bits_divide_conquer(input);
        uint32_t result3 = reverse_bits_lookup(input);
        
        printf("测试用例 %d:\n", i + 1);
        print_binary(input, "输入");
        print_binary(result1, "结果");
        
        // 验证三种方法结果一致
        if (result1 == result2 && result2 == result3) {
            printf("✓ 三种方法结果一致\n");
        } else {
            printf("✗ 方法结果不一致！\n");
            printf("基础方法: %u, 分治方法: %u, 查表方法: %u\n", 
                   result1, result2, result3);
        }
        printf("\n");
    }
}

/**
 * 性能测试函数
 */
void performance_test() {
    const int iterations = 10000000;
    uint32_t test_value = 0x12345678;
    
    printf("=== 性能测试 ===\n");
    printf("测试数据: 0x%08X, 迭代次数: %d\n\n", test_value, iterations);
    
    // 注意：实际性能测试需要更精确的计时工具
    // 这里只是示意性的测试框架
    
    clock_t start, end;
    
    // 测试基础方法
    start = clock();
    for (int i = 0; i < iterations; i++) {
        reverse_bits_basic(test_value);
    }
    end = clock();
    printf("基础方法耗时: %f 秒\n", ((double)(end - start)) / CLOCKS_PER_SEC);
    
    // 测试分治方法
    start = clock();
    for (int i = 0; i < iterations; i++) {
        reverse_bits_divide_conquer(test_value);
    }
    end = clock();
    printf("分治方法耗时: %f 秒\n", ((double)(end - start)) / CLOCKS_PER_SEC);
    
    // 测试查表方法
    start = clock();
    for (int i = 0; i < iterations; i++) {
        reverse_bits_lookup(test_value);
    }
    end = clock();
    printf("查表方法耗时: %f 秒\n", ((double)(end - start)) / CLOCKS_PER_SEC);
}

/**
 * 主函数
 */
int main() {
    printf("NVIDIA 面试题：32位无符号整数位反转\n");
    printf("================================================\n\n");
    
    // 演示分治算法的详细步骤
    printf("首先演示分治算法的工作原理：\n");
    demonstrate_divide_conquer_steps(0x12345678);
    
    // 运行完整测试
    test_reverse_bits();
    
    // 性能测试
    performance_test();
    
    return 0;
}

/*
 * ================================================================================
 * 面试要点总结：
 * 
 * 1. 算法理解：
 *    - 位反转的本质是将二进制位的顺序颠倒
 *    - 可以逐位处理，也可以批量处理
 * 
 * 2. 分治算法深度解析：
 *    - 问题分解：32位 = 2^5，需要5个步骤
 *    - 递归构造：能反转k位 → 能反转2k位
 *    - 并行处理：每步同时处理所有相应的位组
 *    - 数学基础：log₂(32) = 5，体现了分治的对数时间特性
 * 
 * 3. 分治过程详解：
 *    步骤1: 2位反转  - 学会最基础的位交换
 *    步骤2: 4位反转  - 应用2位反转能力到4位范围
 *    步骤3: 8位反转  - 应用4位反转能力到8位范围
 *    步骤4: 16位反转 - 应用8位反转能力到16位范围
 *    步骤5: 32位反转 - 应用16位反转能力到整个32位
 * 
 * 4. 位操作技巧：
 *    - 掩码设计：每个步骤的掩码都是特定的位模式
 *    - 移位操作：左移和右移实现位的重新排列
 *    - OR组合：将处理后的位组合成最终结果
 *    - 并行性：一条指令同时处理多个位组
 * 
 * 5. 优化思路对比：
 *    - 基础方法：O(n)时间，简单直观，适合理解
 *    - 分治方法：O(1)时间，体现算法思维，适合面试
 *    - 查表方法：O(1)时间，空间换时间，适合频繁调用
 * 
 * 6. 面试策略：
 *    - 先给出基础解法，展示问题理解
 *    - 再提出分治优化，展示算法思维
 *    - 最后讨论查表法，展示工程优化意识
 *    - 分析复杂度，展示理论基础
 * 
 * 7. 扩展讨论点：
 *    - 64位扩展：增加第6步交换高低32位
 *    - 硬件支持：某些CPU有专门的位反转指令
 *    - 应用场景：网络字节序、图形处理、加密算法
 *    - 相关问题：位计数、位旋转、位交换等
 * 
 * 8. 分治思想的普遍性：
 *    - 快速傅里叶变换(FFT)：同样的分治位操作思想
 *    - 归并排序：分治思想在排序算法中的应用
 *    - 二分查找：分治思想在搜索算法中的应用
 *    - 快速幂运算：分治思想在数学运算中的应用
 * 
 * 9. 为什么分治法如此高效：
 *    - 无循环：避免分支预测失败
 *    - 并行性：现代CPU可以并行执行位操作
 *    - 缓存友好：固定的操作模式，CPU容易优化
 *    - 指令少：只有5条指令vs32次循环
 * ================================================================================
 */
