/*
 * ================================================================================
 * NVIDIA 面试题：位操作和XOR技巧大全 (Bit Manipulation and XOR Tricks)
 * ================================================================================
 * 
 * 题目描述：
 * 展示各种位操作技巧和XOR运算的巧妙应用，这些技巧在系统编程、
 * 图形处理、加密算法和嵌入式开发中广泛使用。
 * 
 * 涵盖内容：
 * 1. 基础位操作（设置、清除、翻转、检测位）
 * 2. XOR的神奇特性和应用
 * 3. 位计数和位扫描
 * 4. 无分支编程技巧
 * 5. 位域操作和掩码技术
 * 6. 快速数学运算的位操作实现
 * 7. 加密和哈希中的位操作
 * 8. 图形和游戏编程中的位技巧
 * 
 * 考察点：
 * - 对二进制和位操作的深入理解
 * - 算法优化思维
 * - 无分支编程能力
 * - 系统级编程技巧
 * - 数学运算的位操作实现
 * - 内存和性能优化意识
 * ================================================================================
 */

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>
#include <assert.h>

/* ================================================================================
 * 1. 基础位操作技巧
 * ================================================================================ */

/* 设置第n位为1 */
static inline uint32_t set_bit(uint32_t num, int n) {
    return num | (1U << n);
}

/* 清除第n位为0 */
static inline uint32_t clear_bit(uint32_t num, int n) {
    return num & ~(1U << n);
}

/* 翻转第n位 */
static inline uint32_t toggle_bit(uint32_t num, int n) {
    return num ^ (1U << n);
}

/* 检测第n位是否为1 */
static inline bool test_bit(uint32_t num, int n) {
    return (num & (1U << n)) != 0;
}

/* 
 * 获取最低位的1
 * 
 * 原理详解：为什么 num & (-num) 能获取最低位的1？
 * 
 * 数学证明：
 * 
 * 定理1 - 补码表示：
 * 在计算机中，负数使用补码表示：-num = ~num + 1
 * 
 * 定理2 - 位模式特性：
 * 对于任意数字num，设其二进制表示为：
 * num = ...abc1000...000 (最低位1在第k位，后面跟k个0)
 * 
 * 引理1 - 补码的位模式：
 * 证明：-num 的位模式为 ...def1000...000
 * 
 * 证明过程：
 * num  = ...abc1000...000
 * ~num = ...def0111...111  (按位取反，abc→def，1→0，000...000→111...111)
 * -num = ~num + 1 = ...def0111...111 + 1
 *      = ...def1000...000  (右边k个1加1进位到第k位)
 * 
 * 主定理 - AND运算结果：
 * num & (-num) = 000...0001000...000 (只有第k位为1)
 * 
 * 证明：
 * num    = ...abc1000...000
 * -num   = ...def1000...000
 * 
 * 按位分析AND结果：
 * - 第k位：num中为1，-num中为1 → 1 & 1 = 1 ✓
 * - 第k位右边：num中为0，-num中为0 → 0 & 0 = 0 ✓  
 * - 第k位左边：num中为abc，-num中为def (互为反码) → abc & def = 000 ✓
 * 
 * 结论：结果为 2^k，即最低位1的位置值
 * 
 * 具体例子验证：
 * 
 * 例子1 - num = 12 (1100)：
 * 最低位1在第2位
 * ~12 = 0011, -12 = 0100
 * 12 & (-12) = 1100 & 0100 = 0100 = 4 = 2² ✓
 * 
 * 例子2 - num = 6 (0110)：
 * 最低位1在第1位  
 * ~6 = 1001, -6 = 1010
 * 6 & (-6) = 0110 & 1010 = 0010 = 2 = 2¹ ✓
 * 
 * 例子3 - num = 8 (1000)：
 * 最低位1在第3位
 * ~8 = 0111, -8 = 1000  
 * 8 & (-8) = 1000 & 1000 = 1000 = 8 = 2³ ✓
 * 
 * 边界情况：
 * - num = 0：结果为0 (无设置位)
 * - num = 1：结果为1 (最低位就是第0位)
 * 
 * 应用场景：
 * - 树状数组(Fenwick Tree)：for(i += i & (-i))
 * - 位集合遍历：while(mask) { int bit = mask & (-mask); ... }
 * - 快速幂算法：提取二进制位进行计算
 * - 某些动态规划的状态压缩算法
 */
static inline uint32_t get_lowest_set_bit(uint32_t num) {
    return num & (-num);
}

/* 
 * 清除最低位的1 - Brian Kernighan算法核心技巧
 * 
 * 原理详解：为什么 num & (num - 1) 能清除最低位的1？
 * 
 * 核心观察：减1操作对二进制的神奇影响
 * 
 * 1. 减1操作的二进制效果：
 *    当对一个数减1时，会发生以下变化：
 *    - 找到最右边的1
 *    - 将这个1变成0  
 *    - 将这个1右边的所有0变成1
 *    - 左边的位保持不变
 * 
 * 2. 数学证明：
 *    
 *    设 num = ...abc1000...000 (最低位1在第k位，后跟k个0)
 *    
 *    减1操作分析：
 *    - 从第0位开始借位：0-1需要向上借位
 *    - 连续借位直到第k位：第k位的1变成0，提供借位
 *    - 借位结果：第0到k-1位都变成1
 *    
 *    所以：num - 1 = ...abc0111...111
 * 
 * 3. AND运算的选择性清除：
 *    
 *    num     = ...abc1000...000
 *    num - 1 = ...abc0111...111
 *    
 *    按位分析AND结果：
 *    - 第k位：1 & 0 = 0 (最低位1被清除)
 *    - 第k位右边：0 & 1 = 0 (保持为0)
 *    - 第k位左边：相同位 & 相同位 = 相同位 (保持不变)
 *    
 *    结果：num & (num - 1) = ...abc0000...000 (只清除了最低位1)
 * 
 * 4. 具体例子验证：
 *    
 *    例子1 - num = 12 (1100)：
 *    12 - 1 = 11 = 1011
 *    12 & 11 = 1100 & 1011 = 1000 = 8
 *    验证：清除了第2位的1 ✓
 *    
 *    例子2 - num = 6 (0110)：
 *    6 - 1 = 5 = 0101  
 *    6 & 5 = 0110 & 0101 = 0100 = 4
 *    验证：清除了第1位的1 ✓
 *    
 *    例子3 - num = 8 (1000)：
 *    8 - 1 = 7 = 0111
 *    8 & 7 = 1000 & 0111 = 0000 = 0
 *    验证：清除了第3位的1（唯一的1） ✓
 * 
 * 5. 为什么这个技巧如此强大：
 *    
 *    a) 减1操作的巧妙性：
 *       恰好在最低位1的位置创造了"0"
 *       恰好在最低位1右边创造了"1"
 *       为AND操作创造了完美的清除条件
 *    
 *    b) AND操作的选择性：
 *       只保留两个操作数都为1的位
 *       最低位1位置：1 & 0 = 0（被清除）
 *       其他位置：保持原有模式
 *    
 *    c) 数学美感：
 *       一个简单的减法 + 一个AND运算
 *       就能精确地清除目标位
 * 
 * 6. 边界情况：
 *    - num = 0：0 & (-1) = 0 (无1可清除)
 *    - num = 1：1 & 0 = 0 (清除唯一的1)
 *    - num = 2的幂：只有一个1，清除后变0
 * 
 * 7. 应用场景：
 *    - Kernighan位计数算法的核心
 *    - 判断2的幂：num > 0 && (num & (num-1)) == 0
 *    - 位集合的高效遍历
 *    - 稀疏数据结构的优化
 * 
 * 8. Brian Kernighan的贡献：
 *    这个技巧体现了Unix哲学：
 *    - 简洁：最少的操作实现最大的功能
 *    - 强大：一个技巧解决多个问题
 *    - 优雅：数学原理与工程实践的完美结合
 */
static inline uint32_t clear_lowest_set_bit(uint32_t num) {
    return num & (num - 1);
}

/* 
 * 找到最低位1在第几位（位置索引）
 * 
 * 原理详解：如何快速找到最低位1的位置？
 * 
 * 方法1：使用get_lowest_set_bit + log2
 * 方法2：直接计算前导零（更高效）
 * 方法3：循环计数（基础方法）
 * 
 * 数学证明：
 * 
 * 核心思想：
 * 最低位1的位置 = log₂(num & (-num))
 * 
 * 证明：
 * 设最低位1在第k位，则 get_lowest_set_bit(num) = 2^k
 * 所以 k = log₂(2^k) = log₂(get_lowest_set_bit(num))
 * 
 * 实现优化：
 * log₂(x) = 31 - count_leading_zeros(x) (当x > 0时)
 * 
 * 具体例子：
 * 
 * 例子1 - num = 12 (1100)：
 * get_lowest_set_bit(12) = 4 = 2²
 * 位置 = log₂(4) = 2 ✓
 * 
 * 例子2 - num = 6 (0110)：
 * get_lowest_set_bit(6) = 2 = 2¹  
 * 位置 = log₂(2) = 1 ✓
 * 
 * 例子3 - num = 8 (1000)：
 * get_lowest_set_bit(8) = 8 = 2³
 * 位置 = log₂(8) = 3 ✓
 * 
 * 应用场景：
 * - 树状数组的索引计算优化
 * - 位图操作中的位置定位
 * - 算法中需要知道具体位位置的场景
 */
int find_lowest_set_bit_position(uint32_t num) {
    if (num == 0) return -1;  // 无设置位
    
    // 方法1：使用内置函数（最高效）
    #ifdef __GNUC__
    return __builtin_ctz(num);  // Count Trailing Zeros - 直接计算末尾零个数
    #else
    // 方法2：使用我们自己实现的count_trailing_zeros函数
    return count_trailing_zeros(num);
    #endif
}

/* 
 * 找到最高位1在第几位（位置索引）
 * 
 * 原理详解：如何快速找到最高位1的位置？
 * 
 * 核心思想：
 * 最高位1的位置 = 31 - count_leading_zeros(num)
 * 
 * 数学证明：
 * 
 * 定理：对于32位数，如果最高位1在第k位，
 *      那么前导零的个数为 31 - k
 * 
 * 证明：
 * 32位数的位置编号：31, 30, 29, ..., 2, 1, 0
 * 如果最高位1在第k位，那么第31位到第k+1位都是0
 * 前导零个数 = (31 - (k+1)) + 1 = 31 - k
 * 所以 k = 31 - 前导零个数
 * 
 * 具体例子：
 * 
 * 例子1 - num = 12 (00001100)：
 * 最高位1在第3位
 * 前导零个数 = 28 (位31到位4都是0)
 * 位置 = 31 - 28 = 3 ✓
 * 
 * 例子2 - num = 0x80000000：
 * 最高位1在第31位
 * 前导零个数 = 0
 * 位置 = 31 - 0 = 31 ✓
 * 
 * 例子3 - num = 1：
 * 最高位1在第0位
 * 前导零个数 = 31
 * 位置 = 31 - 31 = 0 ✓
 * 
 * 硬件优化：
 * 现代CPU都有专门的指令来计算前导零：
 * - x86: BSR (Bit Scan Reverse)
 * - ARM: CLZ (Count Leading Zeros)
 * - GCC内置函数：__builtin_clz()
 * 
 * 应用场景：
 * - 快速计算log₂值
 * - 位图中最高优先级的查找
 * - 数值范围的快速判断
 * - 某些算法的复杂度分析
 */
int find_highest_set_bit_position(uint32_t num) {
    if (num == 0) return -1;  // 无设置位
    
    // 方法1：使用内置函数（最高效）
    #ifdef __GNUC__
    return 31 - __builtin_clz(num);  // 31 - Count Leading Zeros
    #else
    // 方法2：手工实现前导零计数
    return 31 - count_leading_zeros(num);
    #endif
}

/* 
 * 检测是否为2的幂
 * 
 * 原理详解：为什么 num > 0 && (num & (num - 1)) == 0 能判断2的幂？
 * 
 * 1. 2的幂的特征：
 *    2的幂在二进制表示中只有一个1：
 *    1 = 0001, 2 = 0010, 4 = 0100, 8 = 1000, 16 = 10000, ...
 * 
 * 2. 核心观察：
 *    如果一个数只有一个1，那么清除这个1后结果应该为0
 *    而 num & (num - 1) 正好清除最低位的1
 * 
 * 3. 算法逻辑：
 *    - 如果 num 是2的幂，它只有一个1
 *    - num & (num - 1) 会清除这唯一的1，结果为0
 *    - 如果 num 不是2的幂，它有多个1
 *    - num & (num - 1) 只清除最低位的1，结果不为0
 * 
 * 4. 具体例子：
 *    
 *    例子1 - 8是2的幂：
 *    num = 8 (二进制：1000)
 *    num - 1 = 7 (二进制：0111)
 *    num & (num - 1) = 1000 & 0111 = 0000 = 0 ✓
 *    
 *    例子2 - 12不是2的幂：
 *    num = 12 (二进制：1100)
 *    num - 1 = 11 (二进制：1011)  
 *    num & (num - 1) = 1100 & 1011 = 1000 ≠ 0 ✓
 * 
 * 5. 边界情况处理：
 *    - num > 0：排除0的情况（0不是2的幂）
 *    - 负数：由于使用unsigned，不需要考虑负数
 * 
 * 6. 性能优势：
 *    - O(1)时间复杂度，无循环
 *    - 只需要一次位运算，比除法/取模更快
 *    - 无分支，避免分支预测失败
 * 
 * 7. 应用场景：
 *    - 内存分配器的大小检查
 *    - 哈希表大小验证
 *    - 缓存行大小检测
 *    - 算法中的快速路径优化
 */
static inline bool is_power_of_two(uint32_t num) {
    return num > 0 && (num & (num - 1)) == 0;
}

/* 
 * 向上舍入到最近的2的幂
 * 
 * 原理详解：如何将任意数向上舍入到最近的2的幂？
 * 
 * 1. 核心思想：
 *    将数字转换成"最高位1右边全是1"的形式，然后加1得到2的幂
 *    例如：00010100 → 00011111 → 00100000 (下一个2的幂)
 * 
 * 2. 为什么先减1：
 *    - 如果输入本身就是2的幂，我们希望返回它本身
 *    - 减1后，2的幂变成"最高位0，其余位全1"的形式
 *    - 例如：8(1000) - 1 = 7(0111)，处理后得到8而不是16
 * 
 * 3. 位填充过程：
 *    目标：将最高位1右边的所有位都变成1
 *    
 *    每次 num |= num >> k 操作：
 *    - 将最高位的1复制到右边k个位置
 *    - 逐步填充所有位，直到最高位1右边全部为1
 * 
 * 4. 具体例子 (num = 20)：
 *    
 *    原始: 20 = 00010100
 *    
 *    步骤1: num-- = 19 = 00010011
 *    
 *    步骤2: num |= num >> 1
 *           00010011 |= 00001001 = 00011011
 *           (最高位1复制到右边1位)
 *    
 *    步骤3: num |= num >> 2
 *           00011011 |= 00000110 = 00011111  
 *           (继续填充右边的位)
 *    
 *    步骤4-6: num |= num >> 4/8/16
 *           00011111 (已经全部填充，无变化)
 *    
 *    步骤7: num++ = 00100000 = 32
 *    
 *    结果：20 → 32 (下一个2的幂) ✓
 * 
 * 5. 为什么需要5次右移 (1, 2, 4, 8, 16)：
 *    
 *    核心原理：分治思想 + 指数级覆盖
 *    
 *    a) 数学基础：
 *       - 32位数最多需要填充31位（除最高位外）
 *       - 1 + 2 + 4 + 8 + 16 = 31，恰好覆盖所有位
 *       - 每次右移距离是前一次的2倍，保证指数级扩展
 *    
 *    b) 分治证明（数学归纳法）：
 *       引理：经过k次操作后，最高位1右边的 2^k - 1 位都被填充
 *       
 *       基础：第1次 >> 1，填充 2¹-1 = 1 位 ✓
 *       归纳：如果第k次填充了 2^k-1 位，那么第k+1次 >> 2^k 会
 *             将这些1复制到更右边，总共填充 2^(k+1)-1 位 ✓
 *    
 *    c) 具体覆盖过程：
 *       第1次 >> 1:  填充 1 位   (累计1位)
 *       第2次 >> 2:  填充 2 位   (累计3位) 
 *       第3次 >> 4:  填充 4 位   (累计7位)
 *       第4次 >> 8:  填充 8 位   (累计15位)
 *       第5次 >> 16: 填充 16 位  (累计31位)
 *    
 *    d) 为什么其他序列不行：
 *       - 如果用 >> 3: 1+2+3+8+16=30 < 31 (覆盖不全)
 *       - 如果用 >> 6: 1+2+4+6+16=29 < 31 (覆盖不全)
 *       - 只有2的幂序列能保证完全覆盖且无重复
 *    
 *    e) 可视化"传染"过程：
 *       步骤0: ........1........  (只有1个1)
 *       步骤1: ........11.......  (传染到右边1位)
 *       步骤2: ........1111.....  (传染到右边2位，总共3位)
 *       步骤3: ........11111111..  (传染到右边4位，总共7位)
 *       步骤4: ........1111111111111111  (传染到右边8位，总共15位)
 *       步骤5: 完全填充右边所有31位
 * 
 * 6. 算法正确性：
 *    - 对于任意32位数，最多5次操作就能填充所有位
 *    - 最终得到形如 0001111...111 的数
 *    - 加1后得到 0010000...000，这就是2的幂
 * 
 * 7. 与ROUND_UP(x,2)的区别：
 *    - ROUND_UP(x,2)：对齐到2的倍数(偶数) 如：5→6, 9→10
 *    - 本函数：对齐到2的幂 如：5→8, 9→16
 *    - 完全不同的概念！2的倍数 ≠ 2的幂
 * 
 * 8. 应用场景：
 *    - 内存分配器：将请求大小向上对齐到2的幂
 *    - 哈希表：确保表大小为2的幂以优化取模运算
 *    - 缓存优化：对齐到缓存行大小
 *    - GPU编程：工作组大小必须是2的幂
 */
uint32_t round_up_to_power_of_two(uint32_t num) {
	if (num == 0) return 1;
	
	num--;                // 处理已经是2的幂的情况
	num |= num >> 1;      // 填充右边1位
	num |= num >> 2;      // 填充右边2位
	num |= num >> 4;      // 填充右边4位
	num |= num >> 8;      // 填充右边8位
	num |= num >> 16;     // 填充右边16位
	num++;                // 得到2的幂
	
	return num;
}

/* 
 * 内核风格的通用round_up宏 - Linux内核经典实现
 * 
 * 原理详解：为什么 ((x-1) | (align-1)) + 1 能实现对齐？
 * 
 * 1. 前提条件：
 *    align 必须是2的幂 (1, 2, 4, 8, 16, 32, ...)
 *    当align是2的幂时，align-1的二进制形式是低位全1
 *    例如：align=16时，align-1=15=00001111
 * 
 * 2. 核心思想：
 *    将x向上"填充"到align的边界-1，然后+1得到对齐值
 * 
 * 3. 算法步骤：
 *    步骤1: x-1 (防止已对齐的数被向上舍入)
 *    步骤2: (x-1) | (align-1) (将低位填充为1)
 *    步骤3: 结果+1 (得到对齐的边界)
 * 
 * 4. 详细计算示例：
 *    
 *    主例子 - ROUND_UP(23, 16)：
 *    x=23=00010111, align=16=00010000, mask=15=00001111
 *    步骤1: x-1 = 22 = 00010110
 *    步骤2: 22|15 = 00010110|00001111 = 00011111 (低4位填充为1)
 *    步骤3: 31+1 = 00100000 = 32 ✓
 *    
 *    例子1 - ROUND_UP(5, 8)：
 *    (5-1)|7+1 = 4|7+1 = 00000100|00000111+1 = 00000111+1 = 8 ✓
 *    
 *    例子2 - ROUND_UP(10, 8)：  
 *    (10-1)|7+1 = 9|7+1 = 00001001|00000111+1 = 00001111+1 = 16 ✓
 *    
 *    例子3 - ROUND_UP(8, 8) (已对齐)：
 *    (8-1)|7+1 = 7|7+1 = 00000111|00000111+1 = 00000111+1 = 8 ✓
 *    
 *    例子4 - ROUND_UP(1, 4)：
 *    (1-1)|3+1 = 0|3+1 = 00000000|00000011+1 = 00000011+1 = 4 ✓
 * 
 * 5. 深层数学原理：
 *    
 *    a) 掩码特征：当align是2的幂时
 *       align=2: mask=1=00000001, align=4: mask=3=00000011
 *       align=8: mask=7=00000111, align=16: mask=15=00001111
 *       规律：mask总是"低log₂(align)位全1"的形式
 *    
 *    b) OR操作的本质：
 *       (x-1) | mask 将x的低位全部"推高"到1
 *       相当于将x推到"下一个对齐边界-1"的位置
 *    
 *    c) 进位机制：
 *       当低位全是1时，+1会产生连续进位到对齐位置
 *       例如：00011111 + 1 = 00100000 (进位到第5位)
 *    
 *    d) 几何理解：
 *       数轴映射：0→16→32→48→64...
 *       算法确保 (prev_boundary, next_boundary] → next_boundary
 * 
 * 6. 内核中的实际应用：
 *    - 内存页面对齐：PAGE_ALIGN(addr) 
 *    - 缓存行对齐：CACHE_ALIGN(size)
 *    - DMA缓冲区对齐：dma_alloc_coherent()
 *    - 文件系统块对齐：block_align(offset)
 */
#define ROUND_UP(x, align) ((((x) - 1) | ((align) - 1)) + 1)

/* 
 * 通用对齐函数（支持任意2的幂对齐值）
 * 
 * 这个函数展示了如何复用内核宏来实现更高级的功能
 * 体现了内核编程中"不重复造轮子"的设计理念
 */
static inline uint32_t align_to_power_of_two(uint32_t x, uint32_t align) {
    // 检查align是否为2的幂
    if (!is_power_of_two(align)) {
        printf("警告：对齐值不是2的幂，可能导致错误结果\n");
        return x;
    }
    
    // 直接调用内核风格的ROUND_UP宏
    // 这比重复实现相同逻辑更简洁、更一致
    return ROUND_UP(x, align);
}

/* 页面对齐示例（4KB页面） */
#define PAGE_SIZE 4096
#define PAGE_ALIGN(addr) ROUND_UP(addr, PAGE_SIZE)

/* 缓存行对齐示例（64字节缓存行） */
#define CACHE_LINE_SIZE 64
#define CACHE_ALIGN(size) ROUND_UP(size, CACHE_LINE_SIZE)

#define ALIGN(x, a) (((x) + (a) - 1) & ~((a) - 1))
#define ALIGN_4(x) ALIGN(x, 4)
#define ALIGN_8(x) ALIGN(x, 8)

/* ================================================================================
 * 2. XOR的神奇特性和应用
 * ================================================================================ */

/* 
 * XOR交换两个变量（无需临时变量）
 * 
 * XOR的关键特性：
 * 1. 自反性：a ^ a = 0 (任何数与自己XOR得0)
 * 2. 恒等性：a ^ 0 = a (任何数与0 XOR得自己)
 * 3. 交换律：a ^ b = b ^ a (XOR满足交换律)
 * 4. 结合律：(a ^ b) ^ c = a ^ (b ^ c) (XOR满足结合律)
 * 
 * 数学证明：为什么这样能工作？
 * 
 * 设原始值为 a₀ 和 b₀，追踪每步变化：
 * 
 * 初始状态：a = a₀, b = b₀
 * 
 * 步骤1：*a ^= *b
 *        a = a₀ ^ b₀, b = b₀
 * 
 * 步骤2：*b ^= *a  
 *        a = a₀ ^ b₀, b = b₀ ^ (a₀ ^ b₀)
 *        利用结合律：b = (b₀ ^ a₀) ^ b₀ = a₀ ^ (b₀ ^ b₀) = a₀ ^ 0 = a₀
 *        所以：a = a₀ ^ b₀, b = a₀
 * 
 * 步骤3：*a ^= *b
 *        a = (a₀ ^ b₀) ^ a₀, b = a₀  
 *        利用交换律和结合律：a = (a₀ ^ a₀) ^ b₀ = 0 ^ b₀ = b₀
 *        所以：a = b₀, b = a₀
 * 
 * 最终结果：a = b₀, b = a₀ ✓ (成功交换)
 * 
 * 关键洞察：
 * - 第一步后，a保存了a₀^b₀，这个值包含了两个原始值的所有信息
 * - 通过(a₀^b₀)^b₀=a₀ 可以恢复原始的a
 * - 通过(a₀^b₀)^a₀=b₀ 可以恢复原始的b
 * 
 * 边界条件：为什么需要 if (a != b)？
 * 
 * 如果a和b指向同一地址，会发生：
 * 初始：*a = 5 (a和b指向同一位置)
 * 步骤1：*a ^= *a → *a = 5^5 = 0
 * 步骤2：*a ^= *a → *a = 0^0 = 0  
 * 步骤3：*a ^= *a → *a = 0^0 = 0
 * 结果：原值5丢失，变成0！
 * 
 * 实际应用考虑：
 * - 历史价值：在内存珍贵的年代很有用
 * - 现代实践：编译器能优化传统交换，性能差异不大
 * - 面试价值：展示位操作理解和数学思维
 */
void xor_swap(int* a, int* b) {
    if (a != b) {  // 防止同一地址的情况
        *a ^= *b;  // a = a₀ ^ b₀
        *b ^= *a;  // b = b₀ ^ (a₀ ^ b₀) = a₀
        *a ^= *b;  // a = (a₀ ^ b₀) ^ a₀ = b₀
    }
}

/* 
 * 找出数组中唯一出现奇数次的数字
 * 
 * 问题描述：
 * 数组中有很多数字，其中只有一个数字出现奇数次，
 * 其他所有数字都出现偶数次。找出这个唯一的数字。
 * 
 * 数学证明：
 * 
 * 基础定理：
 * - 交换律：a ^ b = b ^ a
 * - 结合律：(a ^ b) ^ c = a ^ (b ^ c)  
 * - 自反性：a ^ a = 0
 * - 恒等性：a ^ 0 = a
 * 
 * 核心引理：
 * 如果数字x出现偶数次(2k次)，那么：
 * x ^ x ^ ... ^ x (2k个x) = (x^x) ^ (x^x) ^ ... = 0 ^ 0 ^ ... = 0
 * 
 * 算法正确性证明：
 * 设唯一出现奇数次的数字为target，其他数字都出现偶数次
 * 
 * result = arr[0] ^ arr[1] ^ ... ^ arr[n-1]
 * 
 * 利用交换律和结合律重新排列：
 * result = target ^ (偶数次数字的XOR组合)
 * 
 * 由引理可知，所有偶数次数字XOR后为0：
 * result = target ^ 0 = target ✓
 * 
 * 具体例子：[1, 2, 3, 2, 1, 4, 3]
 * 
 * 逐步计算：
 * result = 0
 * result ^= 1 → 1
 * result ^= 2 → 3
 * result ^= 3 → 0  
 * result ^= 2 → 2
 * result ^= 1 → 3
 * result ^= 4 → 7
 * result ^= 3 → 4 ✓
 * 
 * 重排列验证：
 * [1,1,2,2,3,3,4] → 1^1=0, 2^2=0, 3^3=0, 结果=4 ✓
 * 
 * 算法特点：
 * - 时间复杂度：O(n) - 只需遍历一次
 * - 空间复杂度：O(1) - 只用一个变量
 * - 无需排序或哈希表
 */
int find_single_number(int arr[], int n) {
    int result = 0;
    for (int i = 0; i < n; i++) {
        result ^= arr[i];  // 所有偶数次数字会被抵消，只剩奇数次的
    }
    return result;
}

/* 
 * 找出数组中两个唯一出现奇数次的数字
 * 
 * 问题描述：
 * 数组中有很多数字，其中有两个数字出现奇数次，
 * 其他所有数字都出现偶数次。找出这两个数字。
 * 
 * 算法思路：分组策略
 * 
 * 核心挑战：
 * 如果直接XOR所有数字，得到的是target1 ^ target2，
 * 无法直接分离出两个数字。
 * 
 * 解决方案：
 * 利用两个不同数字必然在某位上不同的特性进行分组
 * 
 * 数学证明：
 * 
 * 步骤1证明 - 获取两数XOR：
 * 设两个唯一数字为a和b，其他数字都出现偶数次
 * xor_all = a ^ b ^ (偶数次数字的XOR)
 *         = a ^ b ^ 0  (偶数次数字XOR为0)
 *         = a ^ b
 * 
 * 步骤2证明 - 找到分组位：
 * 因为a ≠ b，所以a ^ b ≠ 0，必然存在某位为1
 * 选择最右边的1位：rightmost_set_bit = (a^b) & (-(a^b))
 * 这一位表示a和b在该位上的值不同
 * 
 * 步骤3证明 - 分组正确性：
 * 
 * 引理1：a和b被分到不同组
 * 证明：因为a和b在分组位上不同，if条件会将它们分开
 * 
 * 引理2：偶数次数字在各组内仍保持偶数次
 * 证明：对于任何出现2k次的数字x，无论x在分组位上是0还是1，
 *       它的所有2k个副本都会被分到同一组，在该组内仍出现2k次
 * 
 * 引理3：每组简化为单数字问题
 * 证明：每组现在都是"一个奇数次数字 + 若干偶数次数字"
 *       使用单数字XOR算法，偶数次数字被抵消
 * 
 * 具体例子：[1, 2, 3, 4, 1, 2]
 * 
 * 步骤1：xor_all = 1^2^3^4^1^2 = (1^1)^(2^2)^3^4 = 0^0^3^4 = 3^4 = 7
 * 
 * 步骤2：rightmost_set_bit = 7 & (-7) = 111 & 11111001 = 001 = 1
 *       (选择第0位作为分组依据)
 * 
 * 步骤3：分组
 *       第0位为1: [1, 3, 1] → num1 = 1^3^1 = (1^1)^3 = 0^3 = 3 ✓
 *       第0位为0: [2, 4, 2] → num2 = 2^4^2 = (2^2)^4 = 0^4 = 4 ✓
 * 
 * 算法特点：
 * - 时间复杂度：O(n) - 两次遍历
 * - 空间复杂度：O(1) - 只用常量空间
 * - 巧妙利用了XOR的数学特性
 * - 分治思想：将复杂问题分解为简单问题
 */
void find_two_single_numbers(int arr[], int n, int* num1, int* num2) {
    int xor_all = 0;
    
    // 步骤1：获取两个目标数字的XOR结果
    for (int i = 0; i < n; i++) {
        xor_all ^= arr[i];
    }
    
    // 步骤2：找到最右边的设置位（分组依据）
    int rightmost_set_bit = xor_all & (-xor_all);
    
    *num1 = 0;
    *num2 = 0;
    
    // 步骤3：根据该位分组，每组内使用单数字XOR算法
    for (int i = 0; i < n; i++) {
        if (arr[i] & rightmost_set_bit) {
            *num1 ^= arr[i];  // 该位为1的数字分到第一组
        } else {
            *num2 ^= arr[i];  // 该位为0的数字分到第二组
        }
    }
}

/* 
 * XOR链表（无需额外指针的双向链表）
 * 
 * 创新思想：用一个指针存储两个指针的信息
 * 
 * 传统双向链表问题：
 * 每个节点需要2个指针：next和prev，内存开销大
 * 
 * XOR链表解决方案：
 * 每个节点只存储一个指针：npx = next XOR prev
 * 节省50%的指针内存！
 * 
 * 数学原理：
 * 
 * 基础：XOR的自反性 a ^ b ^ b = a
 * 
 * 核心思想：
 * 如果 npx = next ^ prev，那么：
 * - 已知prev，可得 next = npx ^ prev
 * - 已知next，可得 prev = npx ^ next
 * 
 * 链表结构示例：
 * NULL ←→ [A] ←→ [B] ←→ [C] ←→ NULL
 * 
 * 节点存储：
 * A->npx = NULL ^ &B
 * B->npx = &A ^ &C  
 * C->npx = &B ^ NULL
 * 
 * 正向遍历算法：
 * 
 * 初始：prev = NULL, curr = head(A)
 * 
 * 步骤1：访问A
 *        next = prev ^ A->npx = NULL ^ (NULL ^ &B) = &B
 *        更新：prev = A, curr = B
 * 
 * 步骤2：访问B  
 *        next = prev ^ B->npx = &A ^ (&A ^ &C) = &C
 *        更新：prev = B, curr = C
 * 
 * 步骤3：访问C
 *        next = prev ^ C->npx = &B ^ (&B ^ NULL) = NULL
 *        结束遍历
 * 
 * 优势：
 * - 内存节省：每个节点节省一个指针（4或8字节）
 * - 支持双向遍历：可以正向和反向遍历
 * - 数学优雅：巧妙利用XOR特性
 * 
 * 劣势：
 * - 实现复杂：需要仔细处理指针运算
 * - 调试困难：npx值不直观，难以调试
 * - 不支持随机访问：必须从头开始遍历
 * - 指针算术：依赖于指针的数值表示
 * 
 * 应用场景：
 * - 内存极度受限的嵌入式系统
 * - 需要大量双向链表的数据结构
 * - 学术研究和算法优化
 * - 面试中展示XOR技巧的理解
 */
typedef struct xor_node {
    int data;
    struct xor_node* npx;  // XOR of next and previous pointers
} xor_node_t;

/* 
 * XOR两个指针
 * 
 * 功能：对两个指针进行XOR运算
 * 
 * 实现细节：
 * - 将指针转换为uintptr_t进行XOR运算
 * - uintptr_t保证能完整存储指针值
 * - 结果转换回指针类型
 * 
 * 数学基础：
 * 指针本质上是内存地址（整数），可以进行位运算
 * XOR运算在指针上的应用遵循相同的数学规律
 */
xor_node_t* xor_pointers(xor_node_t* a, xor_node_t* b) {
    return (xor_node_t*)((uintptr_t)a ^ (uintptr_t)b);
}

/* 
 * XOR链表的正向遍历（前序遍历）
 * 
 * 算法原理：
 * 从头节点开始，利用XOR的自反性逐步计算下一个节点
 * 
 * 遍历过程：
 * 1. 初始化：prev = NULL, curr = head
 * 2. 循环：next = prev XOR curr->npx
 * 3. 更新：prev = curr, curr = next
 * 
 * 数学证明：
 * 设链表为 NULL ←→ A ←→ B ←→ C ←→ NULL
 * 
 * 节点npx值：
 * A->npx = NULL ^ &B = &B
 * B->npx = &A ^ &C
 * C->npx = &B ^ NULL = &B
 * 
 * 遍历步骤：
 * 步骤1: prev=NULL, curr=A
 *        next = NULL ^ A->npx = NULL ^ &B = &B ✓
 * 
 * 步骤2: prev=A, curr=B
 *        next = &A ^ B->npx = &A ^ (&A ^ &C) = &C ✓
 * 
 * 步骤3: prev=B, curr=C  
 *        next = &B ^ C->npx = &B ^ &B = NULL ✓ (结束)
 */
void xor_list_traverse_forward(xor_node_t* head) {
    printf("XOR链表正向遍历: ");
    
    xor_node_t* prev = NULL;
    xor_node_t* curr = head;
    
    while (curr != NULL) {
        printf("%d ", curr->data);
        
        // 计算下一个节点：next = prev XOR curr->npx
        xor_node_t* next = xor_pointers(prev, curr->npx);
        
        // 更新遍历指针
        prev = curr;
        curr = next;
    }
    printf("→ NULL\n");
}

/* 
 * XOR链表的反向遍历（后序遍历）
 * 
 * 算法原理：
 * 从尾节点开始，利用XOR的对称性反向计算前一个节点
 * 
 * 关键洞察：
 * XOR运算具有对称性，如果能正向遍历，就能反向遍历
 * 只需要从尾节点开始，使用相同的XOR逻辑
 * 
 * 反向遍历过程：
 * 1. 初始化：next = NULL, curr = tail  
 * 2. 循环：prev = next XOR curr->npx
 * 3. 更新：next = curr, curr = prev
 * 
 * 数学证明：
 * 设链表为 NULL ←→ A ←→ B ←→ C ←→ NULL
 * 
 * 从C开始反向遍历：
 * 步骤1: next=NULL, curr=C
 *        prev = NULL ^ C->npx = NULL ^ (&B ^ NULL) = &B ✓
 * 
 * 步骤2: next=C, curr=B
 *        prev = &C ^ B->npx = &C ^ (&A ^ &C) = &A ✓
 * 
 * 步骤3: next=B, curr=A
 *        prev = &B ^ A->npx = &B ^ (NULL ^ &B) = NULL ✓ (结束)
 * 
 * 对称性体现：
 * - 正向：prev XOR npx = next
 * - 反向：next XOR npx = prev  
 * - 数学上完全对称，体现了XOR运算的美妙特性
 */
void xor_list_traverse_backward(xor_node_t* tail) {
    printf("XOR链表反向遍历: ");
    
    xor_node_t* next = NULL;
    xor_node_t* curr = tail;
    
    while (curr != NULL) {
        printf("%d ", curr->data);
        
        // 计算前一个节点：prev = next XOR curr->npx
        xor_node_t* prev = xor_pointers(next, curr->npx);
        
        // 更新遍历指针
        next = curr;
        curr = prev;
    }
    printf("→ NULL\n");
}

/* 
 * XOR链表的创建示例
 * 
 * 展示如何创建一个简单的XOR链表并进行双向遍历
 * 这是理解XOR链表最好的实践例子
 */
void demonstrate_xor_list() {
    printf("\n=== XOR链表演示 ===\n");
    
    // 创建节点
    xor_node_t nodeA = {1, NULL};
    xor_node_t nodeB = {2, NULL};  
    xor_node_t nodeC = {3, NULL};
    
    // 设置XOR指针
    // A: NULL ← A → B，所以 A->npx = NULL ^ &B
    nodeA.npx = xor_pointers(NULL, &nodeB);
    
    // B: A ← B → C，所以 B->npx = &A ^ &C
    nodeB.npx = xor_pointers(&nodeA, &nodeC);
    
    // C: B ← C → NULL，所以 C->npx = &B ^ NULL
    nodeC.npx = xor_pointers(&nodeB, NULL);
    
    printf("创建链表: A(1) ←→ B(2) ←→ C(3)\n");
    
    // 正向遍历
    xor_list_traverse_forward(&nodeA);
    
    // 反向遍历  
    xor_list_traverse_backward(&nodeC);
    
    printf("验证：XOR链表成功实现双向遍历！\n\n");
}

/* ================================================================================
 * 3. 位计数技巧
 * ================================================================================ */

/* 
 * 计算32位整数中1的个数 - Brian Kernighan算法
 * 
 * 算法原理：
 * 利用 num & (num - 1) 能清除最右边的1这一特性，
 * 每次循环清除一个1，循环次数就是1的个数。
 * 
 * 核心技巧：num & (num - 1) 清除最低位的1
 * 
 * 数学证明：
 * 
 * 引理：对于任意数字num，num & (num - 1) 清除最低位的1
 * 证明：设 num = ...abc1000 (最低位1后跟k个0)
 *       num - 1 = ...abc0111 (最低位1变0，右边k个0变1)
 *       num & (num - 1) = ...abc0000 (最低位1被清除)
 * 
 * 算法正确性：
 * - 每次迭代清除一个1，计数器加1
 * - 当所有1都被清除后，num变成0，循环结束
 * - 循环次数 = 原数字中1的个数
 * 
 * 具体例子：count_set_bits_kernighan(12)
 * 
 * 12 = 1100 (有2个1)
 * 
 * 第1次循环：
 * num = 12 = 1100
 * num - 1 = 11 = 1011
 * num & (num - 1) = 1100 & 1011 = 1000 (清除右边的1)
 * count = 1, num = 1000
 * 
 * 第2次循环：
 * num = 8 = 1000
 * num - 1 = 7 = 0111  
 * num & (num - 1) = 1000 & 0111 = 0000 (清除最后的1)
 * count = 2, num = 0000
 * 
 * 第3次循环：
 * num = 0，循环结束
 * 
 * 结果：count = 2 ✓
 * 
 * 另一个例子：count_set_bits_kernighan(7)
 * 
 * 7 = 0111 (有3个1)
 * 
 * 第1次：7 & 6 = 0111 & 0110 = 0110, count = 1 (清除最右边的1)
 * 第2次：6 & 5 = 0110 & 0101 = 0100, count = 2 (清除最右边的1)
 * 第3次：4 & 3 = 0100 & 0011 = 0000, count = 3 (清除最后的1)
 * 
 * 结果：count = 3 ✓
 * 
 * 算法特点：
 * - 时间复杂度：O(k)，k是1的个数，最坏情况O(32)
 * - 空间复杂度：O(1)
 * - 优势：只循环k次，而不是32次（比逐位检查更高效）
 * - 适用性：当数字中1的个数较少时特别高效
 * 
 * 与其他方法对比：
 * - 逐位检查：总是循环32次，O(32)
 * - Kernighan算法：只循环k次，O(k)，k≤32
 * - 并行计算：固定操作，O(1)，但指令复杂
 * - 查表法：O(1)，但需要额外内存
 * 
 * Brian Kernighan：
 * 这个算法以Unix之父Brian Kernighan命名，
 * 体现了Unix哲学中"简洁而强大"的设计理念
 * 
 * 应用场景：
 * - 稀疏位图的处理
 * - 网络协议中的位标志计数
 * - 图算法中的邻接矩阵处理
 * - 某些加密算法的辅助计算
 */
int count_set_bits_kernighan(uint32_t num) {
    int count = 0;
    while (num) {
        num &= (num - 1);  // 清除最右边的1
        count++;
    }
    return count;
}

/* 
 * 计算32位整数中1的个数 - 查表法（空间换时间）
 * 
 * 算法原理：
 * 预计算0-255所有8位数的1的个数，然后将32位数分成4个8位段分别查表
 * 
 * 核心思想：分治 + 预计算
 * 1. 预计算：一次性计算0-255的位计数，存储在查找表中
 * 2. 分段处理：将32位数分成4个8位段
 * 3. 查表求和：分别查表后相加得到总计数
 * 
 * 查找表构建的数学原理：
 * 
 * 递推公式：lookup_table[i] = (i & 1) + lookup_table[i / 2]
 * 
 * 数学证明：
 * 对于任意8位数i，其1的个数等于：
 * - 最低位的贡献：i & 1 (0或1)
 * - 剩余7位的贡献：lookup_table[i / 2] (右移1位后的1个数)
 * 
 * 递推过程示例：
 * i=0: 0000, count = (0&1) + table[0] = 0 + 0 = 0 ✓
 * i=1: 0001, count = (1&1) + table[0] = 1 + 0 = 1 ✓
 * i=2: 0010, count = (2&1) + table[1] = 0 + 1 = 1 ✓
 * i=3: 0011, count = (3&1) + table[1] = 1 + 1 = 2 ✓
 * i=4: 0100, count = (4&1) + table[2] = 0 + 1 = 1 ✓
 * i=5: 0101, count = (5&1) + table[2] = 1 + 1 = 2 ✓
 * ...
 * 
 * 32位数的分段处理：
 * 
 * 将32位数按8位分段：
 * 位31-24 | 位23-16 | 位15-8 | 位7-0
 * 
 * 分段提取：
 * 低8位:   num & 0xFF           (位7-0)
 * 次低8位: (num >> 8) & 0xFF    (位15-8)
 * 次高8位: (num >> 16) & 0xFF   (位23-16)  
 * 高8位:   (num >> 24) & 0xFF   (位31-24)
 * 
 * 具体例子：count_set_bits_lookup(0x12345678)
 * 
 * 0x12345678 = 00010010001101000101011001111000
 * 
 * 分段：
 * 高8位:   00010010 = 0x12 = 18  → lookup_table[18]
 * 次高8位: 00110100 = 0x34 = 52  → lookup_table[52]
 * 次低8位: 01010110 = 0x56 = 86  → lookup_table[86]
 * 低8位:   01111000 = 0x78 = 120 → lookup_table[120]
 * 
 * 查表计算：
 * 18 = 00010010 → 2个1
 * 52 = 00110100 → 3个1
 * 86 = 01010110 → 4个1  
 * 120 = 01111000 → 4个1
 * 
 * 总计：2 + 3 + 4 + 4 = 13个1 ✓
 * 
 * 算法特点：
 * - 时间复杂度：O(1) - 固定4次查表操作
 * - 空间复杂度：O(256) - 查找表占用1KB内存
 * - 初始化成本：O(256) - 只需初始化一次
 * - 适用性：高频调用时性能最优
 * 
 * 与其他方法对比：
 * - vs Kernighan：查表法O(1) vs O(k)，但需要额外内存
 * - vs 并行计算：查表法更简单，但内存访问可能有cache miss
 * - vs 逐位检查：查表法快得多，但需要预计算
 * 
 * 优化考虑：
 * - 查找表是静态的，多线程安全
 * - 256个整数在现代系统中内存开销很小
 * - 一次初始化，终身受益
 * - 缓存友好：连续访问模式
 * 
 * 应用场景：
 * - 高频位计数操作
 * - 实时系统中的确定性性能需求
 * - 位图处理和图像算法
 * - 网络协议栈中的快速校验
 * 
 * 扩展思考：
 * - 可以扩展到16位表（64KB内存）获得更好性能
 * - 可以针对特定应用优化表的大小
 * - 在GPU编程中可以利用共享内存存储查找表
 */
int count_set_bits_lookup(uint32_t num) {
    static int lookup_table[256] = {0};
    static bool initialized = false;
    
    // 一次性初始化查找表（线程安全的静态初始化）
    if (!initialized) {
        for (int i = 0; i < 256; i++) {
            lookup_table[i] = (i & 1) + lookup_table[i / 2];
        }
        initialized = true;
    }
    
    // 分4个8位段查表求和
    return lookup_table[num & 0xFF] +           // 低8位
           lookup_table[(num >> 8) & 0xFF] +    // 次低8位
           lookup_table[(num >> 16) & 0xFF] +   // 次高8位
           lookup_table[(num >> 24) & 0xFF];    // 高8位
}

/* 
 * 计算前导零的个数 (Count Leading Zeros)
 * 
 * 功能：计算32位数从最高位开始有多少个连续的0
 * 
 * 算法原理：二分查找思想
 * 
 * 核心思想：
 * 使用分治策略，每次检查一半的位，如果这一半全是0，
 * 就跳过这些位，专注于另一半。
 * 
 * 分治过程：32位 → 16位 → 8位 → 4位 → 2位 → 1位
 * 
 * 详细步骤解析：
 * 
 * 步骤1 - 检查高16位：
 * 掩码 0xFFFF0000 = 11111111111111110000000000000000
 * 如果 num & 0xFFFF0000 == 0，说明高16位全是0
 * 则前导零至少16个，count += 16，然后左移16位专注于低16位
 * 
 * 步骤2 - 检查高8位：  
 * 掩码 0xFF000000 = 11111111000000000000000000000000
 * 在剩余位中，如果高8位全0，count += 8，左移8位
 * 
 * 步骤3 - 检查高4位：
 * 掩码 0xF0000000 = 11110000000000000000000000000000
 * 如果高4位全0，count += 4，左移4位
 * 
 * 步骤4 - 检查高2位：
 * 掩码 0xC0000000 = 11000000000000000000000000000000  
 * 如果高2位全0，count += 2，左移2位
 * 
 * 步骤5 - 检查最高位：
 * 掩码 0x80000000 = 10000000000000000000000000000000
 * 如果最高位是0，count += 1
 * 
 * 具体例子：count_leading_zeros(12)
 * 
 * 12 = 00000000000000000000000000001100
 * 
 * 步骤1: num & 0xFFFF0000 = 0 (高16位全0)
 *        count = 16, num = 00001100000000000000000000000000
 * 
 * 步骤2: num & 0xFF000000 = 0 (高8位全0)  
 *        count = 24, num = 11000000000000000000000000000000
 * 
 * 步骤3: num & 0xF0000000 ≠ 0 (高4位不全0，跳过)
 * 
 * 步骤4: num & 0xC0000000 ≠ 0 (高2位不全0，跳过)
 * 
 * 步骤5: num & 0x80000000 ≠ 0 (最高位不是0，跳过)
 * 
 * 结果：count = 16 + 8 = 24 ... 等等，这不对！
 * 
 * 让我重新分析：12的前导零应该是28个，不是24个
 * 
 * 正确分析：
 * 12 = 00000000000000000000000000001100
 * 最高位1在第3位，所以前导零 = 31 - 3 = 28个
 * 
 * 算法验证：
 * 步骤1: 高16位全0 → count=16, num左移16位变成 00001100...
 * 步骤2: 高8位全0 → count=24, num左移8位变成 1100...  
 * 步骤3: 高4位不全0 (1100中的11) → 跳过
 * 步骤4: 高2位不全0 (11) → 跳过  
 * 步骤5: 最高位不是0 (第一个1) → 跳过
 * 
 * 等等，我的分析还是有问题...让我用更简单的例子
 * 
 * 更简单的例子：count_leading_zeros(8)
 * 
 * 8 = 00000000000000000000000000001000 (第3位是1)
 * 期望结果：31 - 3 = 28个前导零
 * 
 * 算法执行：
 * 步骤1: 8 & 0xFFFF0000 = 0 → count=16, num=8<<16=0x80000
 * 步骤2: 0x80000 & 0xFF000000 = 0 → count=24, num=0x80000<<8=0x8000000  
 * 步骤3: 0x8000000 & 0xF0000000 = 0 → count=28, num=0x8000000<<4=0x80000000
 * 步骤4: 0x80000000 & 0xC0000000 ≠ 0 → 跳过
 * 步骤5: 0x80000000 & 0x80000000 ≠ 0 → 跳过
 * 
 * 结果：count = 28 ✓ 正确！
 * 
 * 算法正确性：
 * - 时间复杂度：O(1) - 固定5次检查
 * - 空间复杂度：O(1) 
 * - 二分思想：每次排除一半可能性
 * - 硬件友好：现代CPU有CLZ指令直接支持
 * 
 * 应用场景：
 * - 快速计算log₂值：log₂(x) = 31 - count_leading_zeros(x)
 * - 位扫描：找到最高位1的位置
 * - 数值范围判断：快速确定数字需要多少位表示
 * - round_up_to_power_of_two等算法的基础
 */
int count_leading_zeros(uint32_t num) {
    if (num == 0) return 32;  // 特殊情况：全0
    
    int count = 0;
    
    // 二分查找：逐步缩小范围
    if (!(num & 0xFFFF0000)) { count += 16; num <<= 16; }  // 检查高16位
    if (!(num & 0xFF000000)) { count += 8;  num <<= 8;  }  // 检查高8位
    if (!(num & 0xF0000000)) { count += 4;  num <<= 4;  }  // 检查高4位
    if (!(num & 0xC0000000)) { count += 2;  num <<= 2;  }  // 检查高2位
    if (!(num & 0x80000000)) { count += 1; }              // 检查最高位
    
    return count;
}

/* 
 * 计算末尾零的个数 (Count Trailing Zeros)
 * 
 * 功能：计算32位数从最低位开始有多少个连续的0
 * 
 * 算法原理：二分查找思想（与count_leading_zeros对称）
 * 
 * 核心思想：
 * 使用分治策略，每次检查一半的位，如果这一半全是0，
 * 就跳过这些位，专注于另一半。
 * 
 * 分治过程：32位 → 16位 → 8位 → 4位 → 2位 → 1位
 * 
 * 详细步骤解析：
 * 
 * 步骤1 - 检查低16位：
 * 掩码 0xFFFF = 00000000000000001111111111111111
 * 如果 num & 0xFFFF == 0，说明低16位全是0
 * 则末尾零至少16个，count += 16，然后右移16位专注于高16位
 * 
 * 步骤2 - 检查低8位：
 * 掩码 0xFF = 00000000000000000000000011111111
 * 在剩余位中，如果低8位全0，count += 8，右移8位
 * 
 * 步骤3 - 检查低4位：
 * 掩码 0xF = 00000000000000000000000000001111
 * 如果低4位全0，count += 4，右移4位
 * 
 * 步骤4 - 检查低2位：
 * 掩码 0x3 = 00000000000000000000000000000011
 * 如果低2位全0，count += 2，右移2位
 * 
 * 步骤5 - 检查最低位：
 * 掩码 0x1 = 00000000000000000000000000000001
 * 如果最低位是0，count += 1
 * 
 * 具体例子：count_trailing_zeros(12)
 * 
 * 12 = 00000000000000000000000000001100
 * 
 * 步骤1: 12 & 0xFFFF ≠ 0 (低16位不全0，跳过)
 * 步骤2: 12 & 0xFF ≠ 0 (低8位不全0，跳过)
 * 步骤3: 12 & 0xF ≠ 0 (低4位不全0，跳过)
 * 步骤4: 12 & 0x3 = 0 (低2位全0)
 *        count = 2, num = 12 >> 2 = 3 = 11
 * 步骤5: 3 & 0x1 ≠ 0 (最低位不是0，跳过)
 * 
 * 结果：count = 2 ✓ (12的最低位1在第2位)
 * 
 * 与count_leading_zeros的对称性：
 * - count_leading_zeros: 从左向右扫描，使用左移和高位掩码
 * - count_trailing_zeros: 从右向左扫描，使用右移和低位掩码
 * - 都使用二分思想，时间复杂度都是O(1)
 * 
 * 应用场景：
 * - 找到最低位1的位置：position = count_trailing_zeros(num)
 * - 树状数组的索引计算
 * - 位图操作中的快速定位
 * - 某些数学算法的优化
 */
int count_trailing_zeros(uint32_t num) {
    if (num == 0) return 32;  // 特殊情况：全0
    
    int count = 0;
    
    // 二分查找：逐步缩小范围（从低位开始）
    if ((num & 0xFFFF) == 0) { count += 16; num >>= 16; }  // 检查低16位
    if ((num & 0xFF) == 0)   { count += 8;  num >>= 8;  }  // 检查低8位
    if ((num & 0xF) == 0)    { count += 4;  num >>= 4;  }  // 检查低4位
    if ((num & 0x3) == 0)    { count += 2;  num >>= 2;  }  // 检查低2位
    if ((num & 0x1) == 0)    { count += 1; }              // 检查最低位
    
    return count;
}

/* ================================================================================
 * 4. 无分支编程技巧
 * ================================================================================ */

/* 
 * 无分支求绝对值
 * 
 * 算法原理：
 * 利用符号位和XOR运算的特性，在不使用条件分支的情况下计算绝对值
 * 
 * 核心思想：
 * 1. 利用符号位创建掩码
 * 2. 利用XOR实现条件操作
 * 
 * 算法步骤：
 * 
 * 步骤1：创建符号掩码
 * mask = x >> 31 (算术右移，符号扩展)
 * - 正数：符号位0，算术右移31位后mask = 0 
 * - 负数：符号位1，算术右移31位后mask = -1 (全1位模式)
 * 
 * 步骤2：条件计算
 * return (x + mask) ^ mask
 * 
 * 数学分析：
 * 
 * 情况1 - x是正数（x ≥ 0）：
 * mask = 0
 * (x + mask) ^ mask = (x + 0) ^ 0 = x ^ 0 = x ✓
 * 
 * 情况2 - x是负数（x < 0）：
 * mask = -1 (全1)
 * (x + mask) ^ mask = (x - 1) ^ (-1)
 * 
 * 关键理解：对于负数x，(x - 1) ^ (-1) = -x
 * 
 * 数学证明：
 * 在补码表示中：-x = ~x + 1，所以 x - 1 = ~(-x)
 * 因此：(x - 1) ^ (-1) = ~(-x) ^ (-1) = ~((-x) ^ (-1)) = ~(~(-x)) = -x ✓
 * 
 * 具体例子：
 * 
 * 例子1 - x = 5 (正数)：
 * mask = 5 >> 31 = 0
 * 结果 = (5 + 0) ^ 0 = 5 ^ 0 = 5 ✓
 * 
 * 例子2 - x = -5 (负数)：
 * mask = (-5) >> 31 = -1 (全1)
 * 结果 = (-5 + (-1)) ^ (-1) = (-6) ^ (-1)
 * 
 * 二进制计算：
 * -5 = 11111111111111111111111111111011
 * -6 = 11111111111111111111111111111010
 * -1 = 11111111111111111111111111111111
 * (-6) ^ (-1) = 00000000000000000000000000000101 = 5 ✓
 * 
 * 例子3 - x = 0：
 * mask = 0 >> 31 = 0
 * 结果 = (0 + 0) ^ 0 = 0 ✓
 * 
 * 算法优势：
 * - 无分支：避免分支预测失败
 * - 高效：只需要3个位操作
 * - 通用：适用于所有32位有符号整数
 * - CPU友好：现代处理器高度优化位操作
 * 
 * 应用场景：
 * - 高性能计算：避免分支开销
 * - 向量化编程：SIMD指令中的无分支操作
 * - GPU编程：避免warp divergence
 * - 实时系统：确定性执行时间
 * 
 * 注意事项：
 * - 只适用于有符号整数
 * - 依赖于算术右移的行为（符号扩展）
 * - 在某些平台上可能不如编译器优化的条件语句
 */
int abs_no_branch(int x) {
    int mask = x >> 31;        // 创建符号掩码
    return (x + mask) ^ mask;  // 条件绝对值计算
}

/* 
 * 无分支求最大值
 * 
 * 算法原理：
 * 利用差值的符号位来判断大小关系，用位操作实现条件选择
 * 
 * 核心思想：
 * 1. 计算差值，利用符号位判断大小关系
 * 2. 创建选择掩码，将布尔条件转换为0/1
 * 3. 用位操作实现条件选择
 * 
 * 算法步骤：
 * 
 * 步骤1：计算差值
 * diff = a - b
 * - 如果 a ≥ b，则 diff ≥ 0 (符号位为0)
 * - 如果 a < b，则 diff < 0 (符号位为1)
 * 
 * 步骤2：创建选择掩码
 * mask = (diff >> 31) & 1
 * - diff ≥ 0：(0 >> 31) & 1 = 0 & 1 = 0
 * - diff < 0：(-1 >> 31) & 1 = (-1) & 1 = 1
 * 
 * 步骤3：条件选择
 * return a - (diff & mask)
 * 
 * 数学分析：
 * 
 * 情况1 - a ≥ b (应该返回a)：
 * mask = 0
 * diff & mask = diff & 0 = 0
 * 结果 = a - 0 = a ✓
 * 
 * 情况2 - a < b (应该返回b)：
 * mask = 1
 * diff & mask = diff & 1 = diff (保留diff的值)
 * 结果 = a - diff = a - (a - b) = b ✓
 * 
 * 具体例子：
 * 
 * 例子1 - max_no_branch(10, 3)：
 * diff = 10 - 3 = 7 (正数)
 * mask = (7 >> 31) & 1 = 0 & 1 = 0
 * 结果 = 10 - (7 & 0) = 10 - 0 = 10 ✓
 * 
 * 例子2 - max_no_branch(3, 10)：
 * diff = 3 - 10 = -7 (负数)
 * mask = ((-7) >> 31) & 1 = (-1) & 1 = 1
 * 结果 = 3 - ((-7) & 1) = 3 - (-7) = 3 + 7 = 10 ✓
 * 
 * 例子3 - max_no_branch(5, 5)：
 * diff = 5 - 5 = 0
 * mask = (0 >> 31) & 1 = 0 & 1 = 0
 * 结果 = 5 - (0 & 0) = 5 - 0 = 5 ✓
 * 
 * 算法巧妙性：
 * 
 * 1. 符号位的妙用：
 *    将大小比较转换为符号位检测
 *    避免了显式的比较操作
 * 
 * 2. 掩码的双重作用：
 *    既是条件标志，又是选择器
 *    通过 & 操作实现条件清零
 * 
 * 3. 数学变换的巧思：
 *    a - (a - b) = b，利用代数恒等式
 *    将选择问题转换为减法问题
 * 
 * 算法优势：
 * - 无分支：避免分支预测失败
 * - 固定时间：执行时间确定性
 * - 向量化友好：适合SIMD优化
 * - GPU友好：避免warp divergence
 * 
 * 应用场景：
 * - 高性能数值计算
 * - 图像处理中的像素比较
 * - 机器学习中的激活函数
 * - 实时系统中的确定性操作
 * 
 * 扩展应用：
 * - 可以类似地实现无分支最小值
 * - 可以扩展到多个数的最大值
 * - 可以用于实现无分支的clamp函数
 */
int max_no_branch(int a, int b) {
    int diff = a - b;
    int mask = (diff >> 31) & 1;  // 如果a < b，mask为1；否则为0
    return a - (diff & mask);
}

/* 
 * 无分支求最小值
 * 
 * 算法原理：
 * 与max_no_branch对称，利用相同的差值和掩码，但用不同的数学变换
 * 
 * 核心思想：
 * 1. 计算差值，利用符号位判断大小关系
 * 2. 创建选择掩码，将布尔条件转换为0/1
 * 3. 用位操作实现条件选择（基于b计算）
 * 
 * 算法步骤：
 * 
 * 步骤1：计算差值
 * diff = a - b
 * - 如果 a ≥ b，则 diff ≥ 0 (符号位为0)
 * - 如果 a < b，则 diff < 0 (符号位为1)
 * 
 * 步骤2：创建选择掩码
 * mask = (diff >> 31) & 1
 * - diff ≥ 0：mask = 0 (a ≥ b的情况)
 * - diff < 0：mask = 1 (a < b的情况)
 * 
 * 步骤3：条件选择
 * return b + (diff & mask)
 * 
 * 数学分析：
 * 
 * 情况1 - a ≥ b (应该返回b)：
 * mask = 0
 * diff & mask = diff & 0 = 0
 * 结果 = b + 0 = b ✓
 * 
 * 情况2 - a < b (应该返回a)：
 * mask = 1
 * diff & mask = diff & 1 = diff (负数差值)
 * 结果 = b + diff = b + (a - b) = a ✓
 * 
 * 具体例子：
 * 
 * 例子1 - min_no_branch(10, 3)：
 * diff = 10 - 3 = 7 (正数)
 * mask = (7 >> 31) & 1 = 0 & 1 = 0
 * 结果 = 3 + (7 & 0) = 3 + 0 = 3 ✓
 * 
 * 例子2 - min_no_branch(3, 10)：
 * diff = 3 - 10 = -7 (负数)
 * mask = ((-7) >> 31) & 1 = (-1) & 1 = 1
 * 结果 = 10 + ((-7) & 1) = 10 + (-7) = 3 ✓
 * 
 * 例子3 - min_no_branch(5, 5)：
 * diff = 5 - 5 = 0
 * mask = (0 >> 31) & 1 = 0 & 1 = 0
 * 结果 = 5 + (0 & 0) = 5 + 0 = 5 ✓
 * 
 * 与max_no_branch的对称性：
 * 
 * max_no_branch: return a - (diff & mask);  // 从a出发
 * min_no_branch: return b + (diff & mask);  // 从b出发
 * 
 * 两者使用相同的diff和mask，但：
 * - 最大值：基于较大候选数a，通过减法得到较小数b
 * - 最小值：基于较小候选数b，通过加法得到较大数a
 * 
 * 数学恒等式：
 * - max算法：a - (a - b) = b (当a < b时返回b)
 * - min算法：b + (a - b) = a (当a < b时返回a)
 * 
 * 算法优势：
 * - 完美对称：max和min算法结构相同
 * - 无分支：避免条件跳转
 * - 高效：只需3个简单操作
 * - 可扩展：可以组合实现clamp等函数
 * 
 * 应用场景：
 * - 数值计算中的边界限制
 * - 图像处理中的像素钳位
 * - 机器学习中的激活函数
 * - 游戏引擎中的物理计算
 * 
 * 组合应用示例：
 * // 无分支clamp函数：将x限制在[min_val, max_val]范围内
 * int clamp_no_branch(int x, int min_val, int max_val) {
 *     return max_no_branch(min_val, min_no_branch(x, max_val));
 * }
 */
int min_no_branch(int a, int b) {
    int diff = a - b;
    int mask = (diff >> 31) & 1;
    return b + (diff & mask);
}

/* 
 * 无分支判断符号是否相同
 * 
 * 算法原理：
 * 利用XOR运算的特性和符号位检测，判断两个有符号整数是否同号
 * 
 * 核心思想：
 * 1. 相同符号位XOR后为0，不同符号位XOR后为1
 * 2. 只检查符号位，忽略数值位
 * 3. 用位操作替代条件比较
 * 
 * 算法步骤：
 * 
 * 步骤1：XOR两个数
 * a ^ b
 * - 如果a和b同号：符号位相同，XOR后符号位为0
 * - 如果a和b异号：符号位不同，XOR后符号位为1
 * 
 * 步骤2：提取符号位
 * (a ^ b) & 0x80000000
 * 掩码 0x80000000 = 10000000000000000000000000000000
 * 只保留第31位（符号位），其他位清零
 * 
 * 步骤3：判断结果
 * ((a ^ b) & 0x80000000) == 0
 * - 符号位为0 → 同号 → 返回true
 * - 符号位为1 → 异号 → 返回false
 * 
 * 数学分析：
 * 
 * XOR运算的符号位特性：
 * - 正数 ^ 正数：0 ^ 0 = 0 (符号位为0)
 * - 负数 ^ 负数：1 ^ 1 = 0 (符号位为0)
 * - 正数 ^ 负数：0 ^ 1 = 1 (符号位为1)
 * - 负数 ^ 正数：1 ^ 0 = 1 (符号位为1)
 * 
 * 具体例子：
 * 
 * 例子1 - same_sign_no_branch(5, 3) (都是正数)：
 * 5  = 00000000000000000000000000000101 (符号位0)
 * 3  = 00000000000000000000000000000011 (符号位0)
 * 5^3= 00000000000000000000000000000110 (符号位0)
 * & 0x80000000 = 0 → 0 == 0 → true ✓
 * 
 * 例子2 - same_sign_no_branch(-5, -3) (都是负数)：
 * -5 = 11111111111111111111111111111011 (符号位1)
 * -3 = 11111111111111111111111111111101 (符号位1)
 * XOR= 00000000000000000000000000000110 (符号位0)
 * & 0x80000000 = 0 → 0 == 0 → true ✓
 * 
 * 例子3 - same_sign_no_branch(5, -3) (异号)：
 * 5  = 00000000000000000000000000000101 (符号位0)
 * -3 = 11111111111111111111111111111101 (符号位1)
 * XOR= 11111111111111111111111111111000 (符号位1)
 * & 0x80000000 = 0x80000000 ≠ 0 → false ✓
 * 
 * 例子4 - same_sign_no_branch(0, 5) (0和正数)：
 * 0  = 00000000000000000000000000000000 (符号位0)
 * 5  = 00000000000000000000000000000101 (符号位0)
 * XOR= 00000000000000000000000000000101 (符号位0)
 * & 0x80000000 = 0 → 0 == 0 → true ✓ (0视为正数)
 * 
 * 算法巧妙性：
 * 
 * 1. XOR的选择性：
 *    只关心符号位的差异，忽略数值位的差异
 *    巧妙地将符号比较转换为位检测
 * 
 * 2. 掩码的精确性：
 *    0x80000000 精确地选择符号位
 *    避免了其他位的干扰
 * 
 * 3. 布尔转换的简洁性：
 *    == 0 将位模式转换为布尔值
 *    符合C语言的真假约定
 * 
 * 算法优势：
 * - 无分支：避免条件跳转
 * - 高效：只需2个位操作 + 1个比较
 * - 直观：算法逻辑清晰易懂
 * - 通用：适用于所有32位有符号整数
 * 
 * 应用场景：
 * - 数值算法中的符号一致性检查
 * - 图形算法中的象限判断
 * - 物理引擎中的方向判断
 * - 金融计算中的盈亏判断
 * 
 * 扩展应用：
 * - 可以扩展到64位整数（修改掩码为0x8000000000000000）
 * - 可以用于实现无分支的符号函数
 * - 可以组合用于复杂的条件逻辑
 * 
 * 边界情况：
 * - 0被视为正数（符号位为0）
 * - INT_MIN的特殊情况需要注意溢出
 */
bool same_sign_no_branch(int a, int b) {
    return ((a ^ b) & 0x80000000) == 0;
}

/* 
 * 无分支条件赋值 - 最通用的无分支技巧
 * 
 * 算法原理：
 * 利用布尔值转掩码 + 位选择的组合，实现无分支的条件赋值
 * 等价于：return condition ? true_val : false_val;
 * 
 * 核心思想：
 * 1. 将布尔条件转换为全0或全1掩码
 * 2. 用掩码选择性地保留或清零候选值
 * 3. 用OR运算合并选择结果
 * 
 * 算法步骤：
 * 
 * 步骤1：创建全能掩码
 * mask = -(int)condition
 * 
 * 布尔值转换：
 * - true → 1，-(1) = -1 = 0xFFFFFFFF (全1掩码)
 * - false → 0，-(0) = 0 = 0x00000000 (全0掩码)
 * 
 * 步骤2：掩码选择
 * return (true_val & mask) | (false_val & ~mask)
 * 
 * 掩码作用：
 * - 全1掩码：x & 0xFFFFFFFF = x (保持原值)
 * - 全0掩码：x & 0x00000000 = 0 (清零)
 * 
 * 数学分析：
 * 
 * 情况1 - condition为true：
 * mask = 0xFFFFFFFF (全1)
 * ~mask = 0x00000000 (全0)
 * 
 * true_val & mask = true_val & 0xFFFFFFFF = true_val
 * false_val & ~mask = false_val & 0x00000000 = 0
 * 结果 = true_val | 0 = true_val ✓
 * 
 * 情况2 - condition为false：
 * mask = 0x00000000 (全0)
 * ~mask = 0xFFFFFFFF (全1)
 * 
 * true_val & mask = true_val & 0x00000000 = 0
 * false_val & ~mask = false_val & 0xFFFFFFFF = false_val
 * 结果 = 0 | false_val = false_val ✓
 * 
 * 具体例子：
 * 
 * 例子1 - conditional_assign_no_branch(true, 100, 200)：
 * mask = -(int)true = -1 = 0xFFFFFFFF
 * true_val & mask = 100 & 0xFFFFFFFF = 100
 * false_val & ~mask = 200 & 0x00000000 = 0
 * 结果 = 100 | 0 = 100 ✓
 * 
 * 例子2 - conditional_assign_no_branch(false, 100, 200)：
 * mask = -(int)false = 0 = 0x00000000
 * true_val & mask = 100 & 0x00000000 = 0
 * false_val & ~mask = 200 & 0xFFFFFFFF = 200
 * 结果 = 0 | 200 = 200 ✓
 * 
 * 例子3 - 边界情况：
 * conditional_assign_no_branch(true, 0, -1) = 0 ✓
 * conditional_assign_no_branch(false, -1, 0) = 0 ✓
 * 
 * 算法巧妙性：
 * 
 * 1. 布尔值的数值化：
 *    将逻辑真假转换为数值0/1
 *    利用负号运算生成全位掩码
 * 
 * 2. 掩码的互补性：
 *    mask和~mask总是互补的
 *    确保只有一个值被选中
 * 
 * 3. OR运算的合并性：
 *    (选中值) | (清零值) = 选中值
 *    优雅地合并两个候选值
 * 
 * 算法优势：
 * - 最通用：可以选择任意类型的值
 * - 无分支：完全避免条件跳转
 * - 高效：只需4个位操作
 * - 可组合：可以嵌套实现复杂逻辑
 * 
 * 应用场景：
 * - 高性能数值计算中的条件选择
 * - SIMD编程中的向量条件操作
 * - GPU编程中避免线程分歧
 * - 实时系统中的确定性逻辑
 * 
 * 扩展应用：
 * - 可以扩展到浮点数（需要类型转换）
 * - 可以用于实现无分支的复杂条件逻辑
 * - 可以组合实现多条件选择（如switch的无分支版本）
 * 
 * 与其他无分支技巧的关系：
 * - abs_no_branch：特化的条件赋值
 * - max/min_no_branch：特化的条件选择
 * - 本函数：最通用的条件赋值框架
 */
int conditional_assign_no_branch(bool condition, int true_val, int false_val) {
    int mask = -(int)condition;  // 布尔值转全位掩码
    return (true_val & mask) | (false_val & ~mask);  // 掩码选择 + OR合并
}

/* ================================================================================
 * 5. 快速数学运算
 * ================================================================================ */

/* 
 * 快速乘以3 - 位操作优化数学运算
 * 
 * 算法原理：
 * 用位移和加法替代乘法运算，提高执行效率
 * 
 * 核心思想：
 * 利用数学分解：x * 3 = x * (2 + 1) = x * 2 + x
 * 再利用位操作：x * 2 = x << 1
 * 
 * 数学基础：
 * 
 * 1. 乘法分解：
 *    x * 3 = x * (2 + 1) = x * 2 + x * 1 = 2x + x
 * 
 * 2. 位移优化：
 *    x << 1 = x * 2^1 = x * 2
 *    左移1位等于乘以2
 * 
 * 3. 最终公式：
 *    x * 3 = (x << 1) + x
 * 
 * 具体例子：
 * 
 * 例子1 - multiply_by_3(5)：
 * x = 5
 * x << 1 = 5 << 1 = 10 (5乘以2)
 * 结果 = 10 + 5 = 15
 * 验证：5 * 3 = 15 ✓
 * 
 * 例子2 - multiply_by_3(7)：
 * x = 7 = 111 (二进制)
 * x << 1 = 1110 = 14
 * 结果 = 14 + 7 = 21
 * 验证：7 * 3 = 21 ✓
 * 
 * 例子3 - multiply_by_3(-4)：
 * x = -4
 * x << 1 = -8 (左移保持符号)
 * 结果 = -8 + (-4) = -12
 * 验证：-4 * 3 = -12 ✓
 * 
 * 性能分析：
 * 
 * 传统乘法：
 * imul eax, 3    ; 整数乘法指令，3-5个CPU周期
 * 
 * 位操作版本：
 * shl eax, 1     ; 左移指令，1个CPU周期
 * add eax, ebx   ; 加法指令，1个CPU周期
 * 总计：2个CPU周期
 * 
 * 性能提升：50-60%的速度提升
 * 
 * 扩展应用：
 * 
 * 类似优化可以应用到其他常数：
 * - 乘以5：(x << 2) + x = x * 4 + x
 * - 乘以9：(x << 3) + x = x * 8 + x  
 * - 乘以7：(x << 3) - x = x * 8 - x
 * - 乘以6：(x << 2) + (x << 1) = x * 4 + x * 2
 * 
 * 一般规律：
 * 如果常数C可以表示为2的幂的和或差：
 * C = 2^a ± 2^b ± 2^c ± ...
 * 则：x * C = (x << a) ± (x << b) ± (x << c) ± ...
 * 
 * 算法优势：
 * - 性能：比乘法指令快50-60%
 * - 确定性：执行时间固定
 * - 通用性：适用于正数和负数
 * - 可组合：可以组合实现复杂乘法
 * 
 * 应用场景：
 * - 图形渲染：坐标变换中的常数乘法
 * - 科学计算：数值算法中的系数计算
 * - 游戏引擎：物理计算中的常数运算
 * - 嵌入式系统：没有硬件乘法器的平台
 * 
 * 现代考虑：
 * - 编译器优化：现代编译器通常会自动进行这种优化
 * - 可读性权衡：手工优化vs代码可读性的平衡
 * - 教学价值：理解位操作在数学运算中的应用
 * - 面试价值：展示对底层优化的理解
 */
static inline int multiply_by_3(int x) {
    return (x << 1) + x;  // x * 2 + x
}

/* 
 * 快速除以3（对于正数） - 魔法数字算法
 * 
 * 算法原理：
 * 用乘法和位移替代除法运算，避免使用慢速的除法指令
 * 
 * 核心思想：
 * 除以3等价于乘以1/3，找到1/3的二进制近似表示
 * 
 * 数学推导：
 * 
 * 1. 倒数的二进制展开：
 *    1/3 = 0.333333... (十进制)
 *        = 0.010101010101... (二进制)
 *        = 1/4 + 1/16 + 1/64 + 1/256 + ...
 *        = Σ(1/4^n) for n=1,2,3,...
 * 
 * 2. 有限精度近似：
 *    在32位系统中，我们需要找到一个32位整数M，使得：
 *    M / 2^32 ≈ 1/3
 *    
 *    计算：M = (2^32) / 3 ≈ 1431655765.33...
 *    取整：M = 0x55555556 = 1431655766
 * 
 * 3. 精度验证：
 *    0x55555556 / 2^32 = 1431655766 / 4294967296 ≈ 0.33333333348
 *    误差：约为 2.3 × 10^-10，非常小！
 * 
 * 算法实现：
 * x / 3 ≈ x * (1/3) ≈ x * (0x55555556 / 2^32) = (x * 0x55555556) >> 32
 * 
 * 具体例子：
 * 
 * 例子1 - divide_by_3(12)：
 * x * 0x55555556 = 12 * 1431655766 = 17179869192
 * 17179869192 >> 32 = 17179869192 / 4294967296 = 4.0
 * 结果：4 ✓ (12 / 3 = 4)
 * 
 * 例子2 - divide_by_3(27)：
 * x * 0x55555556 = 27 * 1431655766 = 38699705482  
 * 38699705482 >> 32 = 9.0
 * 结果：9 ✓ (27 / 3 = 9)
 * 
 * 例子3 - divide_by_3(100)：
 * x * 0x55555556 = 100 * 1431655766 = 143165576600
 * 143165576600 >> 32 = 33.333...
 * 结果：33 ✓ (100 / 3 = 33.333..., 整数除法得33)
 * 
 * 性能分析：
 * 
 * 传统除法：
 * div eax, 3     ; 除法指令，20-40个CPU周期
 * 
 * 魔法数字版本：
 * imul rax, 0x55555556  ; 乘法指令，3-5个CPU周期  
 * shr rax, 32           ; 右移指令，1个CPU周期
 * 总计：4-6个CPU周期
 * 
 * 性能提升：5-10倍的速度提升！
 * 
 * 算法局限性：
 * 
 * 1. 精度限制：
 *    由于是近似计算，对某些边界值可能有±1误差
 *    需要根据应用场景评估可接受性
 * 
 * 2. 正数限制：
 *    这个特定魔法数字只对正数有效
 *    负数需要特殊处理或使用不同的魔法数字
 * 
 * 3. 溢出风险：
 *    x * 0x55555556 可能产生64位中间结果
 *    在32位系统上需要小心处理
 * 
 * 魔法数字的计算方法：
 * 
 * 对于除法 x / d，魔法数字 M = ceil(2^n / d)
 * 其中 n 通常选择32或64，取决于目标精度
 * 
 * 除以3：M = ceil(2^32 / 3) = ceil(1431655765.33) = 1431655766 = 0x55555556
 * 除以5：M = ceil(2^32 / 5) = 858993460 = 0x33333334
 * 除以7：M = ceil(2^32 / 7) = 613566757 = 0x24924925
 * 
 * 应用场景：
 * - 高频除法运算的性能优化
 * - 嵌入式系统中避免除法指令
 * - 编译器优化中的常数除法
 * - 数值算法中的系数计算
 * 
 * 现代考虑：
 * - 编译器通常会自动应用这种优化
 * - 了解原理有助于理解编译器行为
 * - 在某些特殊场景下仍需手工优化
 * - 面试中展示对底层优化的深度理解
 */
int divide_by_3(int x) {
    return (x * 0x55555556) >> 32;  // 魔法数字近似除法
}

/* 
 * 快速模运算（当除数是2的幂时）
 * 
 * 算法原理：
 * 利用2的幂的二进制特性，用位操作替代模运算，实现极大的性能提升
 * 
 * 核心思想：
 * x % 2^n = x的低n位
 * 
 * 数学基础：
 * 
 * 1. 2的幂的二进制特征：
 *    2^1 = 2 = 00000010 (只有第1位是1)
 *    2^2 = 4 = 00000100 (只有第2位是1)  
 *    2^3 = 8 = 00001000 (只有第3位是1)
 *    规律：2的幂在二进制中只有一个1
 * 
 * 2. 2的幂减1的特征：
 *    2-1 = 1 = 00000001 (低1位全1)
 *    4-1 = 3 = 00000011 (低2位全1)
 *    8-1 = 7 = 00000111 (低3位全1)
 *    规律：2的幂减1后，低n位全1，高位全0
 * 
 * 3. 模运算的本质：
 *    任何数x都可以表示为：x = q × 2^n + r，其中 0 ≤ r < 2^n
 *    这里的r就是 x % 2^n，而r恰好就是x的低n位！
 * 
 * 数学证明：
 * 
 * 定理：对于正整数x和2的幂p = 2^n，x % p = x & (p - 1)
 * 
 * 证明：
 * 设 p = 2^n，则 p - 1 = 2^n - 1 = 00...0011...11 (低n位全1)
 * 设 x = ...an...a1a0 (二进制表示)
 * 
 * x & (p - 1) = ...an...a1a0 & 00...0011...11 = 00...00an-1...a1a0
 * 
 * 这个结果正是x的低n位，也就是x除以2^n的余数 ✓
 * 
 * 具体例子：
 * 
 * 例子1 - 23 % 8：
 * x = 23 = 00010111
 * power_of_2 = 8 = 00001000
 * power_of_2 - 1 = 7 = 00000111 (低3位全1)
 * x & 7 = 00010111 & 00000111 = 00000111 = 7
 * 验证：23 % 8 = 7 ✓
 * 
 * 例子2 - 100 % 16：
 * x = 100 = 01100100
 * power_of_2 = 16 = 00010000
 * power_of_2 - 1 = 15 = 00001111 (低4位全1)
 * x & 15 = 01100100 & 00001111 = 00000100 = 4
 * 验证：100 % 16 = 4 ✓
 * 
 * 例子3 - 255 % 32：
 * x = 255 = 11111111
 * power_of_2 = 32 = 00100000
 * power_of_2 - 1 = 31 = 00011111 (低5位全1)
 * x & 31 = 11111111 & 00011111 = 00011111 = 31
 * 验证：255 % 32 = 31 ✓
 * 
 * 性能分析：
 * 
 * 传统模运算：
 * div eax, 8     ; 除法指令，20-40个CPU周期
 * mov eax, edx   ; 取余数，1个CPU周期
 * 总计：21-41个CPU周期
 * 
 * 位操作版本：
 * and eax, 7     ; AND指令，1个CPU周期
 * 
 * 性能提升：20-40倍的速度提升！
 * 
 * 常见应用：
 * 
 * 1. 数组索引的循环：
 *    index = (index + 1) & (array_size - 1);  // 当array_size是2的幂
 * 
 * 2. 哈希表的桶选择：
 *    bucket = hash & (table_size - 1);  // 当table_size是2的幂
 * 
 * 3. 位图的位置计算：
 *    bit_index = address & (BITS_PER_WORD - 1);
 * 
 * 4. 缓冲区的环形访问：
 *    buffer_pos = offset & (BUFFER_SIZE - 1);
 * 
 * 算法优势：
 * - 极致性能：比除法快20-40倍
 * - 硬件友好：AND是最基础的位操作
 * - 无副作用：不产生中间结果
 * - 确定性：执行时间固定
 * 
 * 使用条件：
 * - 除数必须是2的幂
 * - 被除数必须是非负数（负数的模运算更复杂）
 * - 需要整数结果
 * 
 * 应用场景：
 * - 哈希表实现：快速计算桶索引
 * - 环形缓冲区：快速计算位置
 * - 位图操作：快速计算位位置
 * - 游戏引擎：纹理坐标包装
 * - 内存分配器：对齐计算
 * 
 * 扩展技巧：
 * - 可以组合实现更复杂的模运算
 * - 可以用于实现快速的周期性函数
 * - 可以优化某些数学算法中的取余操作
 */
static inline int mod_power_of_2(int x, int power_of_2) {
    return x & (power_of_2 - 1);
}

/* 
 * 快速平方根（整数） - 二进制长除法算法
 * 
 * 算法原理：
 * 使用类似手工计算平方根的方法，但在二进制中进行
 * 逐位构建平方根，每次试探当前位是否可以设为1
 * 
 * 核心思想：
 * 模拟手工平方根计算的二进制版本，从高位到低位逐位确定结果
 * 
 * 数学基础：
 * 
 * 1. 平方根的位构造：
 *    如果要计算√x，结果的每一位都可以通过试探确定
 *    从最高位开始，每次试探当前位设为1是否可行
 * 
 * 2. 试探条件：
 *    设当前已构建的结果为r，试探位为b
 *    如果 (r + b)² ≤ x，则可以在r中设置位b
 * 
 * 3. 算法不变式：
 *    在执行过程中始终保持：result² + 当前x = 原始x
 *    这保证了算法的正确性
 * 
 * 算法步骤：
 * 
 * 步骤1：初始化
 * result = 0 (逐步构建的平方根)
 * bit = 1U << 30 (从最高可能位开始)
 * 
 * 步骤2：找到合适的起始位
 * while (bit > x) bit >>= 2;
 * 确保bit不会太大，避免无意义的试探
 * 
 * 步骤3：逐位试探
 * 对每一位，检查 x ≥ result + bit
 * - 如果成立：设置这一位，更新x和result
 * - 如果不成立：跳过这一位
 * 
 * 具体例子：fast_sqrt(25)
 * 
 * 目标：计算√25 = 5
 * 
 * 初始化：
 * x = 25, result = 0, bit = 1 << 30 (很大的数)
 * 
 * 第一阶段 - 找起始位：
 * bit = 1 << 30 > 25，右移2位
 * bit = 1 << 28 > 25，继续右移
 * ...
 * bit = 1 << 4 = 16 ≤ 25，停止
 * 
 * 第二阶段 - 逐位试探：
 * 
 * 迭代1：bit = 16, result = 0
 * 试探：result + bit = 0 + 16 = 16
 * 检查：25 ≥ 16 ✓
 * 更新：x = 25 - 16 = 9, result = (0 >> 1) + 16 = 16
 * bit = 16 >> 2 = 4
 * 
 * 迭代2：bit = 4, result = 16
 * 试探：result + bit = 16 + 4 = 20  
 * 检查：9 ≥ 20 ✗
 * 更新：result = 16 >> 1 = 8
 * bit = 4 >> 2 = 1
 * 
 * 迭代3：bit = 1, result = 8
 * 试探：result + bit = 8 + 1 = 9
 * 检查：9 ≥ 9 ✓
 * 更新：x = 9 - 9 = 0, result = (8 >> 1) + 1 = 5
 * bit = 1 >> 2 = 0
 * 
 * 结果：5 ✓
 * 
 * 为什么bit每次右移2位：
 * 
 * 在二进制平方根算法中，每次处理的是"一对位"
 * 因为平方运算会产生进位，需要考虑相邻位的影响
 * 右移2位确保了正确的位对齐
 * 
 * 算法正确性：
 * 
 * 不变式证明：
 * 设算法过程中result为r，剩余值为x'，原始值为x₀
 * 则始终有：r² + x' = x₀
 * 
 * 这保证了最终result就是√x₀的整数部分
 * 
 * 算法特点：
 * - 时间复杂度：O(log x) ≈ O(16) (最多16次迭代)
 * - 空间复杂度：O(1)
 * - 精度：返回整数平方根（向下取整）
 * - 适用范围：32位无符号整数
 * 
 * 性能分析：
 * 
 * vs 标准库sqrt：
 * - 标准库：浮点运算，需要类型转换
 * - 本算法：纯整数运算，无类型转换开销
 * 
 * vs 牛顿迭代法：
 * - 牛顿法：需要除法运算
 * - 本算法：只需位操作和加减法
 * 
 * 应用场景：
 * - 嵌入式系统：无浮点单元的平台
 * - 图形算法：像素距离计算
 * - 数值算法：整数域的平方根计算
 * - 游戏引擎：快速距离估算
 * - 密码学：某些数论算法
 * 
 * 扩展应用：
 * - 可以修改为计算立方根
 * - 可以扩展到64位整数
 * - 可以用于实现快速的距离函数
 */
uint32_t fast_sqrt(uint32_t x) {
    if (x == 0) return 0;
    
    uint32_t result = 0;
    uint32_t bit = 1U << 30;  // 从最高可能位开始
    
    // 第一阶段：找到合适的起始位
    while (bit > x) {
        bit >>= 2;
    }
    
    // 第二阶段：逐位试探构建平方根
    while (bit != 0) {
        if (x >= result + bit) {
            x -= result + bit;                    // 减去当前试探值
            result = (result >> 1) + bit;        // 设置当前位
        } else {
            result >>= 1;                        // 跳过当前位
        }
        bit >>= 2;                               // 移到下一位对
    }
    
    return result;
}

/* 
 * 快速对数底2（整数） - 位扫描算法
 * 
 * 算法原理：
 * 利用最高位1的位置来计算以2为底的对数（向下取整）
 * 
 * 核心洞察：
 * 最高位1的位置 = ⌊log₂(x)⌋
 * 
 * 数学基础：
 * 
 * 1. 对数的定义：
 *    如果 2^k ≤ x < 2^(k+1)，则 ⌊log₂(x)⌋ = k
 * 
 * 2. 最高位1的含义：
 *    如果x的最高位1在第k位，说明：
 *    2^k ≤ x < 2^(k+1)
 *    因此：⌊log₂(x)⌋ = k
 * 
 * 3. 位置计算：
 *    在32位系统中，位置编号为31, 30, 29, ..., 1, 0
 *    如果最高位1在第k位，前导零个数 = 31 - k
 *    所以：k = 31 - count_leading_zeros(x)
 * 
 * 算法实现：
 * fast_log2(x) = 31 - count_leading_zeros(x)
 * 
 * 具体例子：
 * 
 * 例子1 - fast_log2(8)：
 * 8 = 00000000000000000000000000001000 (第3位是1)
 * 前导零个数 = 28
 * 结果 = 31 - 28 = 3
 * 验证：log₂(8) = log₂(2³) = 3 ✓
 * 
 * 例子2 - fast_log2(100)：
 * 100 = 00000000000000000000000001100100 (第6位是最高位1)
 * 前导零个数 = 25
 * 结果 = 31 - 25 = 6
 * 验证：log₂(100) ≈ 6.64, ⌊6.64⌋ = 6 ✓
 * 
 * 例子3 - fast_log2(1)：
 * 1 = 00000000000000000000000000000001 (第0位是1)
 * 前导零个数 = 31  
 * 结果 = 31 - 31 = 0
 * 验证：log₂(1) = 0 ✓
 * 
 * 例子4 - fast_log2(2^16)：
 * 65536 = 00000000000000010000000000000000 (第16位是1)
 * 前导零个数 = 15
 * 结果 = 31 - 15 = 16
 * 验证：log₂(65536) = 16 ✓
 * 
 * 边界情况：
 * 
 * 1. x = 0：
 *    log₂(0) 在数学上未定义，返回-1表示错误
 * 
 * 2. x = 1：
 *    log₂(1) = 0，这是对数的基本性质
 * 
 * 3. x = 2^k (2的幂)：
 *    log₂(2^k) = k，算法给出精确结果
 * 
 * 4. x = 2^k - 1：
 *    结果为k-1，符合向下取整的要求
 * 
 * 性能分析：
 * 
 * vs 标准库log2：
 * - 标准库：浮点运算，需要类型转换，约10-20个周期
 * - 本算法：整数运算 + 位扫描，约5-10个周期
 * 
 * vs 循环计算：
 * - 循环版本：while (x >>= 1) count++，最多32次迭代
 * - 本算法：利用count_leading_zeros，固定时间
 * 
 * 算法特点：
 * - 时间复杂度：O(1) - 依赖count_leading_zeros的复杂度
 * - 空间复杂度：O(1)
 * - 精度：整数对数（向下取整）
 * - 范围：32位无符号整数
 * 
 * 应用场景：
 * 
 * 1. 算法分析：
 *    快速估算数据规模：log₂(n) 给出所需的位数
 * 
 * 2. 数据结构：
 *    二叉树深度计算：depth = log₂(nodes) + 1
 * 
 * 3. 内存管理：
 *    快速计算内存块的大小等级
 * 
 * 4. 哈希算法：
 *    计算哈希表的最优大小
 * 
 * 5. 图形算法：
 *    Mipmap层级计算：level = log₂(texture_size)
 * 
 * 6. 网络协议：
 *    快速计算数据包的大小类别
 * 
 * 扩展应用：
 * - 可以用于实现快速的位宽计算
 * - 可以优化某些分治算法的深度分析
 * - 可以用于实现高效的数值范围判断
 * 
 * 数学美感：
 * 这个算法展示了二进制表示的数学美：
 * 最高位的位置直接对应对数值，
 * 将复杂的对数运算简化为简单的位扫描
 */
int fast_log2(uint32_t x) {
    if (x == 0) return -1;  // log₂(0)未定义
    return 31 - count_leading_zeros(x);
}

/* ================================================================================
 * 6. 位域和掩码技术
 * ================================================================================ */

/* RGB颜色位域操作 */
typedef union {
    uint32_t value;
    struct {
        uint8_t b : 8;
        uint8_t g : 8;
        uint8_t r : 8;
        uint8_t a : 8;
    } components;
} color_t;

/* 
 * 提取RGB分量 - 为什么使用位操作而不是位域？
 * 
 * 算法原理：
 * 使用位移和掩码操作提取32位颜色值中的RGB分量
 * 
 * 颜色格式：0xAARRGGBB (Alpha, Red, Green, Blue)
 * - Alpha: 位31-24
 * - Red:   位23-16  
 * - Green: 位15-8
 * - Blue:  位7-0
 * 
 * 位操作实现：
 * *r = (color >> 16) & 0xFF;  // 提取位23-16
 * *g = (color >> 8) & 0xFF;   // 提取位15-8
 * *b = color & 0xFF;          // 提取位7-0
 * 
 * 为什么不使用位域？
 * 
 * 虽然我们定义了color_t联合体，但在实际提取中使用位操作，原因如下：
 * 
 * 1. 可移植性问题：
 *    位域的内存布局依赖于：
 *    - 编译器实现
 *    - 目标平台字节序
 *    - 编译器的位分配策略
 * 
 *    示例：
 *    color = 0x12345678
 *    小端序：可能得到 b=0x78, g=0x56, r=0x34
 *    大端序：可能得到 b=0x12, g=0x34, r=0x56
 * 
 * 2. 性能考虑：
 *    位域方式：
 *    color_t c; c.value = color; *r = c.components.r;
 *    可能涉及内存读写和额外的位提取操作
 * 
 *    位操作方式：
 *    *r = (color >> 16) & 0xFF;
 *    直接的位操作，编译器容易优化为单条指令
 * 
 * 3. 明确性和控制：
 *    位操作方式：
 *    - 操作语义完全明确
 *    - 在所有平台上行为一致
 *    - 程序员完全控制每个位的处理
 * 
 *    位域方式：
 *    - 依赖编译器的实现细节
 *    - 可能有隐藏的性能开销
 *    - 行为可能因平台而异
 * 
 * 4. 图形编程的标准做法：
 *    在图形编程中，通常使用位操作进行颜色处理：
 *    - OpenGL/DirectX的颜色格式处理
 *    - 图像处理库的像素操作
 *    - GPU着色器中的颜色计算
 * 
 * 具体例子：
 * 
 * 输入：color = 0x12345678
 * 
 * 位操作结果：
 * *r = (0x12345678 >> 16) & 0xFF = 0x34 & 0xFF = 0x34 = 52
 * *g = (0x12345678 >> 8) & 0xFF = 0x3456 & 0xFF = 0x56 = 86  
 * *b = 0x12345678 & 0xFF = 0x78 = 120
 * 
 * 这个结果在所有平台上都一致 ✓
 * 
 * 位域的适用场景：
 * - 数据结构定义：清晰表达内存布局
 * - 协议解析：与特定格式匹配
 * - 内存优化：精确控制存储大小
 * 
 * 位操作的适用场景：
 * - 跨平台代码：保证行为一致性
 * - 性能关键代码：需要最高效率
 * - 精确控制：需要明确的位操作语义
 * 
 * 总结：
 * 位域适合数据定义，位操作适合数据处理
 * 在图形编程等性能敏感的场景中，位操作是首选
 */
void extract_rgb(uint32_t color, uint8_t* r, uint8_t* g, uint8_t* b) {
    *r = (color >> 16) & 0xFF;  // 提取红色分量（位23-16）
    *g = (color >> 8) & 0xFF;   // 提取绿色分量（位15-8）
    *b = color & 0xFF;          // 提取蓝色分量（位7-0）
}

/* 组合RGB分量 */
uint32_t combine_rgb(uint8_t r, uint8_t g, uint8_t b) {
    return ((uint32_t)r << 16) | ((uint32_t)g << 8) | b;
}

/* 位图操作 */
typedef struct {
    uint32_t* bits;
    int size;
} bitmap_t;

void bitmap_set(bitmap_t* bmp, int index) {
    int word_index = index / 32;
    int bit_index = index % 32;
    bmp->bits[word_index] |= (1U << bit_index);
}

void bitmap_clear(bitmap_t* bmp, int index) {
    int word_index = index / 32;
    int bit_index = index % 32;
    bmp->bits[word_index] &= ~(1U << bit_index);
}

bool bitmap_test(bitmap_t* bmp, int index) {
    int word_index = index / 32;
    int bit_index = index % 32;
    return (bmp->bits[word_index] & (1U << bit_index)) != 0;
}

/* ================================================================================
 * 7. 加密和哈希技巧
 * ================================================================================ */

/* 
 * 简单XOR加密/解密 - 最基础的对称加密
 * 
 * 算法原理：
 * 利用XOR运算的自反性实现对称加密，加密和解密使用相同操作
 * 
 * 核心思想：
 * XOR的自反性：(plaintext ^ key) ^ key = plaintext
 * 
 * 数学基础：
 * 
 * XOR运算的关键特性：
 * - 自反性：a ^ a = 0
 * - 恒等性：a ^ 0 = a  
 * - 交换律：a ^ b = b ^ a
 * - 结合律：(a ^ b) ^ c = a ^ (b ^ c)
 * 
 * 加密解密证明：
 * 设明文为P，密钥为K
 * 加密：C = P ^ K
 * 解密：P' = C ^ K = (P ^ K) ^ K = P ^ (K ^ K) = P ^ 0 = P ✓
 * 
 * 算法步骤：
 * 1. 对每个字节，与密钥进行XOR运算
 * 2. 加密和解密使用完全相同的操作
 * 3. 原地操作，无需额外内存
 * 
 * 具体例子：
 * 
 * 明文："Hello" = [72, 101, 108, 108, 111]
 * 密钥：42
 * 
 * 加密过程：
 * 72 ^ 42 = 114, 101 ^ 42 = 75, 108 ^ 42 = 66, 108 ^ 42 = 66, 111 ^ 42 = 69
 * 密文：[114, 75, 66, 66, 69]
 * 
 * 解密过程（相同操作）：
 * 114 ^ 42 = 72, 75 ^ 42 = 101, 66 ^ 42 = 108, 66 ^ 42 = 108, 69 ^ 42 = 111
 * 明文："Hello" ✓
 * 
 * 算法优势：
 * - 极简：只需要XOR运算
 * - 高效：单周期位操作
 * - 对称：加密解密相同
 * - 原地：无需额外内存
 * 
 * 安全性局限：
 * - 密钥重用：相同明文产生相同密文
 * - 模式暴露：重复模式容易被发现
 * - 频率分析：容易受到统计攻击
 * - 密钥单一：单字节密钥空间太小
 * 
 * 应用场景：
 * - 简单数据混淆
 * - 教学演示
 * - 快速数据变换
 * - 某些特殊协议的简单加密
 * 
 * 注意事项：
 * - 不适用于安全要求高的场景
 * - 密钥管理需要特别注意
 * - 容易被频率分析攻击
 */
void xor_encrypt_decrypt(uint8_t* data, int len, uint8_t key) {
    for (int i = 0; i < len; i++) {
        data[i] ^= key;  // 对每个字节与密钥XOR
    }
}

/* 
 * 循环XOR加密 - 改进的多字节密钥版本
 * 
 * 算法原理：
 * 使用多字节密钥循环加密，提高安全性和复杂度
 * 
 * 改进之处：
 * 1. 多字节密钥：增大密钥空间
 * 2. 循环使用：密钥长度可以与数据长度不同
 * 3. 更强安全性：比单字节密钥更难破解
 * 
 * 核心思想：
 * 当数据长度超过密钥长度时，密钥循环使用
 * data[i] ^= key[i % key_len]
 * 
 * 算法步骤：
 * 1. 对每个数据字节，计算对应的密钥字节索引
 * 2. 使用模运算实现密钥的循环使用
 * 3. 执行XOR运算
 * 
 * 具体例子：
 * 
 * 明文："Hello World" = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]
 * 密钥：[42, 17, 99] (3字节密钥)
 * 
 * 加密过程：
 * data[0] ^= key[0 % 3] = 72 ^ 42 = 114
 * data[1] ^= key[1 % 3] = 101 ^ 17 = 116  
 * data[2] ^= key[2 % 3] = 108 ^ 99 = 11
 * data[3] ^= key[3 % 3] = 108 ^ 42 = 66  (密钥循环)
 * data[4] ^= key[4 % 3] = 111 ^ 17 = 126
 * data[5] ^= key[5 % 3] = 32 ^ 99 = 67
 * ...
 * 
 * 密钥循环模式：
 * 数据索引: 0  1  2  3  4  5  6  7  8  9  10
 * 密钥索引: 0  1  2  0  1  2  0  1  2  0  1
 * 密钥值:  42 17 99 42 17 99 42 17 99 42 17
 * 
 * 安全性改进：
 * 
 * 1. 密钥空间增大：
 *    - 单字节：256种可能
 *    - 3字节：256³ = 16,777,216种可能
 * 
 * 2. 模式复杂化：
 *    - 相同明文字节在不同位置产生不同密文
 *    - 增加了频率分析的难度
 * 
 * 3. 周期性：
 *    - 加密模式的周期 = 密钥长度
 *    - 更长的密钥提供更好的安全性
 * 
 * 算法优势：
 * - 简单高效：基本的XOR运算
 * - 灵活密钥：支持任意长度密钥
 * - 对称性：加密解密相同
 * - 流式处理：可以逐字节处理
 * 
 * 安全性考虑：
 * - 仍然容易受到已知明文攻击
 * - 密钥重用会暴露模式
 * - 不适用于高安全要求的场景
 * - 需要配合其他安全措施使用
 * 
 * 应用场景：
 * - 简单数据混淆和保护
 * - 网络协议中的轻量级加密
 * - 游戏数据的防篡改
 * - 配置文件的简单加密
 * - 教学和演示用途
 * 
 * 现代密码学地位：
 * - 不适合单独用于安全通信
 * - 可作为复杂加密算法的组件
 * - 在流密码中有重要应用
 * - 是理解现代密码学的基础
 */
void cyclic_xor_encrypt(uint8_t* data, int len, uint8_t* key, int key_len) {
    for (int i = 0; i < len; i++) {
        data[i] ^= key[i % key_len];  // 循环使用密钥
    }
}

/* 
 * 简单哈希函数（使用位操作） - djb2哈希算法
 * 
 * 算法原理：
 * 著名的djb2哈希算法，由Dan Bernstein设计，使用位操作优化的字符串哈希
 * 
 * 核心公式：
 * hash = hash * 33 + c (对每个字符c)
 * 
 * 位操作优化：
 * hash * 33 = hash * (32 + 1) = hash * 32 + hash = (hash << 5) + hash
 * 
 * 数学基础：
 * 
 * 1. 多项式哈希的本质：
 *    这个算法计算多项式：
 *    hash = 5381 × 33^n + c₁ × 33^(n-1) + c₂ × 33^(n-2) + ... + cₙ
 *    其中 c₁, c₂, ..., cₙ 是字符的ASCII值
 * 
 * 2. 常数选择的考虑：
 *    - 初始值5381：经验选择的质数，有良好分布特性
 *    - 乘数33：33 = 32 + 1，便于位操作优化
 *    - 质数特性：有助于减少哈希冲突
 * 
 * 3. 位移优化原理：
 *    hash * 33 = hash * (2^5 + 1) = (hash << 5) + hash
 *    左移5位等于乘以32，避免了乘法指令
 * 
 * 算法步骤：
 * 1. 初始化hash为5381
 * 2. 对每个字符，执行：hash = (hash << 5) + hash + c
 * 3. 返回最终的hash值
 * 
 * 具体例子：计算"ABC"的哈希值
 * 
 * 初始：hash = 5381
 * 
 * 第1次迭代（'A'，ASCII=65）：
 * hash = ((5381 << 5) + 5381) + 65
 *      = (172192 + 5381) + 65
 *      = 177638
 * 
 * 第2次迭代（'B'，ASCII=66）：
 * hash = ((177638 << 5) + 177638) + 66
 *      = (5684416 + 177638) + 66
 *      = 5862120
 * 
 * 第3次迭代（'C'，ASCII=67）：
 * hash = ((5862120 << 5) + 5862120) + 67
 *      = (187607840 + 5862120) + 67
 *      = 193470027
 * 
 * 最终结果：193470027
 * 
 * 算法特性：
 * 
 * 1. 雪崩效应：
 *    每个字符都会影响最终结果的所有位
 *    小的输入变化导致大的输出变化
 * 
 * 2. 分布均匀性：
 *    对于随机字符串，哈希值分布相对均匀
 *    减少了哈希冲突的概率
 * 
 * 3. 计算简单：
 *    只需要位移、加法和字符访问
 *    避免了复杂的数学运算
 * 
 * 性能分析：
 * 
 * vs 复杂哈希算法：
 * - 本算法：简单快速，适合一般用途
 * - 复杂算法：安全性更高，但计算开销大
 * 
 * vs 简单累加：
 * - 简单累加：hash += c，分布很差
 * - 本算法：乘法因子提供更好分布
 * 
 * 时间复杂度：O(n)，n是字符串长度
 * 空间复杂度：O(1)
 * 
 * 应用场景：
 * 
 * 1. 哈希表实现：
 *    计算字符串键的哈希值
 * 
 * 2. 数据去重：
 *    快速比较字符串是否相同
 * 
 * 3. 缓存系统：
 *    根据键名计算缓存位置
 * 
 * 4. 编译器：
 *    符号表中的标识符哈希
 * 
 * 5. 数据库：
 *    索引和查找优化
 * 
 * 6. 网络协议：
 *    快速数据校验和计算
 * 
 * 算法变种：
 * - djb2a：使用XOR而不是加法
 * - sdbm：hash = c + (hash << 6) + (hash << 16) - hash
 * - lose lose：简单的累加版本
 * 
 * 安全性考虑：
 * - 不适用于密码学哈希
 * - 容易受到哈希碰撞攻击
 * - 主要用于非安全场景的快速哈希
 * 
 * Dan Bernstein的贡献：
 * 这个算法以其简洁性和有效性而闻名
 * 在C标准库和许多系统中被广泛使用
 */
uint32_t simple_hash(const char* str) {
    uint32_t hash = 5381;
    while (*str) {
        hash = ((hash << 5) + hash) + *str++;  // hash * 33 + c
    }
    return hash;
}

/* 
 * FNV-1a哈希算法 - 高质量的非密码学哈希函数
 * 
 * 算法原理：
 * FNV (Fowler-Noll-Vo) 哈希算法的1a变种，以优秀的分布特性著称
 * 
 * 核心公式：
 * 对每个字节：hash = (hash ^ byte) * FNV_prime
 * 
 * 算法特点：
 * 1. 先XOR后乘法（与FNV-1的顺序相反）
 * 2. 使用精心选择的质数常数
 * 3. 利用32位溢出增加随机性
 * 
 * 魔法常数：
 * 
 * 1. FNV offset basis：2166136261U
 *    - 这是一个精心选择的32位初始值
 *    - 通过数学分析和统计测试选定
 *    - 提供良好的初始分布
 * 
 * 2. FNV prime：16777619U  
 *    - 这是一个特殊的质数：2^24 + 2^8 + 0x93
 *    - 质数特性有助于减少哈希冲突
 *    - 大小适中，既不会太小也不会太大
 * 
 * 算法步骤：
 * 1. 初始化hash为FNV offset basis
 * 2. 对每个字节：
 *    a) 与当前hash进行XOR运算（混合）
 *    b) 乘以FNV prime（扩散）
 * 3. 返回最终hash值
 * 
 * 与djb2的对比：
 * 
 * djb2:   hash = hash * 33 + c     (乘法 → 加法)
 * FNV-1a: hash = (hash ^ c) * prime (XOR → 乘法)
 * 
 * FNV-1a的优势：
 * - XOR提供更好的位混合
 * - 质数乘法提供更好的扩散
 * - 整体分布质量更优
 * 
 * 数学分析：
 * 
 * 1. XOR混合的作用：
 *    hash ^= data[i] 将输入字节与当前状态混合
 *    确保每个输入位都能影响哈希状态
 * 
 * 2. 质数乘法的扩散：
 *    乘以质数将混合后的值扩散到整个32位空间
 *    质数的特性有助于避免周期性模式
 * 
 * 3. 溢出的有益性：
 *    32位乘法溢出相当于模2^32运算
 *    这种"自然截断"增加了哈希的随机性
 * 
 * 算法优势：
 * 
 * 1. 分布质量：
 *    - 优秀的雪崩效应
 *    - 低碰撞率
 *    - 均匀分布
 * 
 * 2. 计算效率：
 *    - 简单的操作序列
 *    - 无复杂的数学运算
 *    - 缓存友好的访问模式
 * 
 * 3. 实现简单：
 *    - 代码量少
 *    - 无复杂的状态管理
 *    - 易于理解和实现
 * 
 * 应用场景：
 * 
 * 1. 哈希表：
 *    高质量的字符串和数据哈希
 * 
 * 2. 校验和：
 *    数据完整性的快速检查
 * 
 * 3. 去重系统：
 *    大数据处理中的快速去重
 * 
 * 4. 缓存系统：
 *    分布式缓存的键哈希
 * 
 * 5. 数据库：
 *    索引和分区的哈希计算
 * 
 * 6. 网络协议：
 *    数据包的快速标识
 * 
 * 算法变种：
 * - FNV-1a 64位版本：使用64位常数和运算
 * - FNV-1：先乘法后XOR的版本
 * - FNV-0：最原始的版本
 * 
 * 安全性考虑：
 * - 非密码学哈希：不适用于安全敏感场景
 * - 可预测性：攻击者可以构造碰撞
 * - 适用范围：主要用于数据结构和快速校验
 * 
 * Fowler, Noll, Vo的贡献：
 * FNV算法以其发明者命名，在哈希算法领域有重要地位
 * 被广泛应用于各种系统和编程语言中
 */
uint32_t fnv1a_hash(const uint8_t* data, int len) {
    uint32_t hash = 2166136261U;  // FNV offset basis
    for (int i = 0; i < len; i++) {
        hash ^= data[i];          // XOR混合
        hash *= 16777619U;       // 质数扩散
    }
    return hash;
}

/* ================================================================================
 * 8. 图形和游戏编程技巧
 * ================================================================================ */

/* 
 * 快速颜色混合（Alpha blending） - 图形编程核心算法
 * 
 * 算法原理：
 * 实现半透明效果，将源颜色和目标颜色按透明度混合
 * 
 * 数学公式：
 * result = src * alpha + dst * (1 - alpha)
 * 其中 alpha ∈ [0, 255]，0=完全透明，255=完全不透明
 * 
 * 位操作优化：
 * 
 * 1. 通道分离策略：
 *    - RB通道：0xFF00FF 掩码选择R和B（位31-24, 7-0）
 *    - G通道：0x00FF00 掩码选择G（位15-8）
 *    - 分离计算避免通道间进位干扰
 * 
 * 2. 并行计算：
 *    RB通道可以同时计算，G通道单独计算
 *    最后用OR运算合并结果
 * 
 * 3. 定点运算：
 *    使用整数运算替代浮点运算，提高性能
 *    >> 8 等价于除以256，实现归一化
 * 
 * 具体例子：
 * 
 * src = 0xFF0000FF (红色，alpha=255)
 * dst = 0xFF00FF00 (绿色，alpha=255)  
 * alpha = 128 (50%透明度)
 * 
 * RB通道计算：
 * src_rb = 0xFF0000FF & 0xFF00FF = 0xFF0000FF
 * dst_rb = 0xFF00FF00 & 0xFF00FF = 0xFF000000
 * rb = ((0xFF0000FF * 128 + 0xFF000000 * 127) >> 8) & 0xFF00FF
 * 
 * G通道计算：
 * src_g = 0xFF0000FF & 0x00FF00 = 0x000000
 * dst_g = 0xFF00FF00 & 0x00FF00 = 0x00FF00
 * g = ((0x000000 * 128 + 0x00FF00 * 127) >> 8) & 0x00FF00
 * 
 * 应用场景：
 * - 2D图形渲染的半透明效果
 * - UI界面的窗口合成
 * - 游戏引擎的特效渲染
 * - 图像处理的混合模式
 */
uint32_t alpha_blend(uint32_t src, uint32_t dst, uint8_t alpha) {
    uint32_t rb = (((src & 0xFF00FF) * alpha + (dst & 0xFF00FF) * (255 - alpha)) >> 8) & 0xFF00FF;
    uint32_t g = (((src & 0x00FF00) * alpha + (dst & 0x00FF00) * (255 - alpha)) >> 8) & 0x00FF00;
    return rb | g;
}

/* 
 * 快速颜色灰度转换 - 基于人眼视觉的加权算法
 * 
 * 算法原理：
 * 基于人眼对不同颜色敏感度的差异，使用加权平均计算灰度值
 * 
 * 标准公式：
 * Gray = 0.299*R + 0.587*G + 0.114*B
 * 
 * 系数来源：
 * - 人眼对绿色最敏感（0.587权重最大）
 * - 对红色中等敏感（0.299）
 * - 对蓝色最不敏感（0.114权重最小）
 * 
 * 整数优化：
 * 将浮点系数转换为整数，避免浮点运算：
 * 0.299 ≈ 77/256
 * 0.587 ≈ 150/256
 * 0.114 ≈ 29/256
 * 
 * 优化公式：
 * Gray = (77*R + 150*G + 29*B) / 256 = (77*R + 150*G + 29*B) >> 8
 * 
 * 验证：77 + 150 + 29 = 256，权重和为256，确保归一化正确
 * 
 * 具体例子：
 * R=255, G=0, B=0 (纯红色)
 * Gray = (77*255 + 150*0 + 29*0) >> 8 = 19635 >> 8 = 76
 * 
 * R=0, G=255, B=0 (纯绿色)  
 * Gray = (77*0 + 150*255 + 29*0) >> 8 = 38250 >> 8 = 149
 * 
 * R=0, G=0, B=255 (纯蓝色)
 * Gray = (77*0 + 150*0 + 29*255) >> 8 = 7395 >> 8 = 28
 * 
 * 应用场景：
 * - 图像处理中的灰度转换
 * - 计算机视觉的预处理
 * - 打印系统的颜色转换
 * - 显示器校准和色彩管理
 */
uint8_t rgb_to_grayscale(uint8_t r, uint8_t g, uint8_t b) {
    // 使用加权平均：0.299*R + 0.587*G + 0.114*B
    // 近似为：(77*R + 150*G + 29*B) >> 8
    return (77 * r + 150 * g + 29 * b) >> 8;
}

/* 
 * 2D坐标到1D索引的转换 - 图形编程基础
 * 
 * 算法原理：
 * 将2D数组的坐标转换为1D数组的索引，这是图形编程的基础操作
 * 
 * 数学基础：
 * 对于宽度为width的2D数组，坐标(x,y)对应的1D索引为：
 * index = y * width + x
 * 
 * 内存布局：
 * 2D视图：        1D内存布局：
 * [0,0][0,1][0,2]  →  [0][1][2][3][4][5][6][7][8]
 * [1,0][1,1][1,2]      ↑     ↑     ↑
 * [2,0][2,1][2,2]      0     3     6
 * 
 * 计算示例：
 * width = 3
 * (0,0) → 0*3 + 0 = 0
 * (1,2) → 1*3 + 2 = 5
 * (2,1) → 2*3 + 1 = 7
 * 
 * 应用场景：
 * - 图像处理：像素数组的访问
 * - 游戏引擎：地图数据的存储和访问
 * - 矩阵运算：2D矩阵的1D存储
 * - 纹理映射：纹理坐标的索引计算
 */
static inline int coord_to_index(int x, int y, int width) {
    return y * width + x;
}

/* 
 * Morton编码（Z-order curve） - 空间数据结构的基础
 * 
 * 算法原理：
 * 将2D坐标编码为1D值，同时保持空间局部性
 * 这是一种空间填充曲线，广泛用于空间数据结构
 * 
 * 编码规律：
 * 交替插入x和y坐标的位：
 * 结果 = ...y₃x₃y₂x₂y₁x₁y₀x₀
 * 
 * 数学意义：
 * Morton编码创建了Z字形的空间遍历模式：
 * 0→1→4→5→2→3→6→7→...
 * 
 * 具体例子：
 * 
 * x = 5 = 0101 (二进制)
 * y = 3 = 0011 (二进制)
 * 
 * 编码过程：
 * i=0: x₀=1, y₀=1 → 位置0放x₀=1, 位置1放y₀=1 → 11
 * i=1: x₁=0, y₁=1 → 位置2放x₁=0, 位置3放y₁=1 → 1011
 * i=2: x₂=1, y₂=0 → 位置4放x₂=1, 位置5放y₂=0 → 101011
 * i=3: x₃=0, y₃=0 → 位置6放x₃=0, 位置7放y₃=0 → 00101011
 * 
 * 最终结果：00101011 = 43
 * 
 * 算法实现分析：
 * ((x & (1U << i)) << i)：提取x的第i位，左移i位放到偶数位置
 * ((y & (1U << i)) << (i + 1))：提取y的第i位，左移i+1位放到奇数位置
 * 
 * 空间局部性：
 * 在2D空间中相近的点，其Morton编码值也相近
 * 这使得空间查询更高效
 * 
 * 应用场景：
 * 
 * 1. 四叉树/八叉树：
 *    节点索引的计算
 * 
 * 2. 空间数据库：
 *    地理信息系统的索引
 * 
 * 3. 图像压缩：
 *    像素数据的重排序
 * 
 * 4. 游戏引擎：
 *    场景管理和碰撞检测
 * 
 * 5. 科学计算：
 *    多维数据的线性化
 * 
 * 6. GPU编程：
 *    纹理内存的访问优化
 * 
 * 算法优势：
 * - 空间局部性：相近坐标产生相近编码
 * - 分治友好：支持递归分割
 * - 缓存优化：提高内存访问效率
 * - 查询加速：加速范围查询
 */
uint32_t morton_encode(uint16_t x, uint16_t y) {
    uint32_t result = 0;
    for (int i = 0; i < 16; i++) {
        result |= ((x & (1U << i)) << i) | ((y & (1U << i)) << (i + 1));
    }
    return result;
}

/* ================================================================================
 * 测试和演示函数
 * ================================================================================ */

void test_basic_bit_operations() {
    printf("=== 基础位操作测试 ===\n");
    
    uint32_t num = 0x12345678;
    printf("原始数字: 0x%08X\n", num);
    
    printf("设置第3位: 0x%08X\n", set_bit(num, 3));
    printf("清除第4位: 0x%08X\n", clear_bit(num, 4));
    printf("翻转第5位: 0x%08X\n", toggle_bit(num, 5));
    printf("第6位状态: %s\n", test_bit(num, 6) ? "设置" : "清除");
    
    printf("是否为2的幂: %s\n", is_power_of_two(num) ? "是" : "否");
    printf("向上舍入到2的幂: 0x%08X\n", round_up_to_power_of_two(num));
    
    printf("最低设置位: 0x%08X\n", get_lowest_set_bit(num));
    printf("清除最低设置位: 0x%08X\n", clear_lowest_set_bit(num));
    printf("最低位1的位置: %d\n", find_lowest_set_bit_position(num));
    printf("最高位1的位置: %d\n", find_highest_set_bit_position(num));
    printf("\n");
}

void test_bit_position_finding() {
    printf("=== 位位置查找测试 ===\n");
    
    uint32_t test_cases[] = {
        1,          // 00000001 - 最低位0，最高位0
        2,          // 00000010 - 最低位1，最高位1  
        4,          // 00000100 - 最低位2，最高位2
        6,          // 00000110 - 最低位1，最高位2
        8,          // 00001000 - 最低位3，最高位3
        12,         // 00001100 - 最低位2，最高位3
        0x80000000, // 10000000000000000000000000000000 - 最低位31，最高位31
        0x80000001, // 10000000000000000000000000000001 - 最低位0，最高位31
        0x12345678  // 测试数据
    };
    
    int num_tests = sizeof(test_cases) / sizeof(test_cases[0]);
    
    printf("数字        二进制(部分)    最低位1位置  最高位1位置\n");
    printf("----------  --------------  ----------  ----------\n");
    
    for (int i = 0; i < num_tests; i++) {
        uint32_t num = test_cases[i];
        int lowest_pos = find_lowest_set_bit_position(num);
        int highest_pos = find_highest_set_bit_position(num);
        
        printf("0x%08X  ", num);
        
        // 打印部分二进制（最后8位）
        for (int j = 7; j >= 0; j--) {
            printf("%d", (num >> j) & 1);
        }
        printf("...     ");
        
        printf("%10d  %11d\n", lowest_pos, highest_pos);
        
        // 验证结果
        if (lowest_pos >= 0 && (num & (1U << lowest_pos)) == 0) {
            printf("错误：最低位1位置计算错误！\n");
        }
        if (highest_pos >= 0 && (num & (1U << highest_pos)) == 0) {
            printf("错误：最高位1位置计算错误！\n");
        }
    }
    printf("\n");
}

void test_kernel_style_round_up() {
    printf("=== 内核风格round_up测试 ===\n");
    
    // 测试各种对齐场景
    struct {
        uint32_t value;
        uint32_t align;
        const char* description;
    } test_cases[] = {
        {23, 16, "内存对齐到16字节"},
        {100, 64, "缓存行对齐到64字节"},
        {1000, PAGE_SIZE, "页面对齐到4KB"},
        {15, 16, "已对齐的情况"},
        {16, 16, "恰好对齐的情况"},
        {17, 16, "超出1字节的情况"}
    };
    
    int num_tests = sizeof(test_cases) / sizeof(test_cases[0]);
    
    for (int i = 0; i < num_tests; i++) {
        uint32_t value = test_cases[i].value;
        uint32_t align = test_cases[i].align;
        
        uint32_t result1 = ROUND_UP(value, align);
        uint32_t result2 = align_to_power_of_two(value, align);
        
        printf("%s:\n", test_cases[i].description);
        printf("  原始值: %u, 对齐到: %u\n", value, align);
        printf("  宏版本结果: %u\n", result1);
        printf("  函数版本结果: %u\n", result2);
        printf("  验证: %s\n", (result1 == result2) ? "✓ 一致" : "✗ 不一致");
        printf("\n");
    }
    
    // 演示内核中常见的用法
    printf("内核中的典型用法示例:\n");
    
    uint32_t addr = 0x12345;
    printf("地址 0x%X 页面对齐后: 0x%X\n", addr, PAGE_ALIGN(addr));
    
    uint32_t size = 100;
    printf("大小 %u 缓存行对齐后: %u\n", size, CACHE_ALIGN(size));
    
    printf("\n");
}

void test_xor_tricks() {
    printf("=== XOR技巧测试 ===\n");
    
    // XOR交换测试
    int a = 42, b = 17;
    printf("交换前: a=%d, b=%d\n", a, b);
    xor_swap(&a, &b);
    printf("交换后: a=%d, b=%d\n", a, b);
    
    // 找单独数字测试
    int arr1[] = {1, 2, 3, 2, 1, 4, 3};
    int single = find_single_number(arr1, 7);
    printf("数组中唯一的数字: %d\n", single);
    
    // 找两个单独数字测试
    int arr2[] = {1, 2, 3, 4, 1, 2};
    int num1, num2;
    find_two_single_numbers(arr2, 6, &num1, &num2);
    printf("两个唯一的数字: %d, %d\n", num1, num2);
    printf("\n");
}

void test_bit_counting() {
    printf("=== 位计数测试 ===\n");
    
    uint32_t test_nums[] = {0x12345678, 0xFFFFFFFF, 0x80000001, 0x00000000};
    int num_tests = sizeof(test_nums) / sizeof(test_nums[0]);
    
    for (int i = 0; i < num_tests; i++) {
        uint32_t num = test_nums[i];
        printf("数字 0x%08X:\n", num);
        printf("  Kernighan算法: %d个1\n", count_set_bits_kernighan(num));
        printf("  查表法: %d个1\n", count_set_bits_lookup(num));
        printf("  前导零个数: %d\n", count_leading_zeros(num));
    }
    printf("\n");
}

void test_branchless_programming() {
    printf("=== 无分支编程测试 ===\n");
    
    int test_vals[] = {-42, 17, 0, -1, 100};
    int num_vals = sizeof(test_vals) / sizeof(test_vals[0]);
    
    for (int i = 0; i < num_vals; i++) {
        int val = test_vals[i];
        printf("值 %d:\n", val);
        printf("  绝对值: %d\n", abs_no_branch(val));
        printf("  与42的最大值: %d\n", max_no_branch(val, 42));
        printf("  与42的最小值: %d\n", min_no_branch(val, 42));
        printf("  与42符号相同: %s\n", same_sign_no_branch(val, 42) ? "是" : "否");
    }
    printf("\n");
}

void test_fast_math() {
    printf("=== 快速数学运算测试 ===\n");
    
    int test_vals[] = {12, 27, 64, 100, 255};
    int num_vals = sizeof(test_vals) / sizeof(test_vals[0]);
    
    for (int i = 0; i < num_vals; i++) {
        int val = test_vals[i];
        printf("值 %d:\n", val);
        printf("  乘以3: %d\n", multiply_by_3(val));
        if (val > 0) {
            printf("  除以3: %d\n", divide_by_3(val));
            printf("  模8: %d\n", mod_power_of_2(val, 8));
            printf("  平方根: %d\n", fast_sqrt(val));
            printf("  log2: %d\n", fast_log2(val));
        }
    }
    printf("\n");
}

void test_color_operations() {
    printf("=== 颜色操作测试 ===\n");
    
    uint32_t color = 0x12345678;
    uint8_t r, g, b;
    extract_rgb(color, &r, &g, &b);
    printf("颜色 0x%08X 分解为: R=%d, G=%d, B=%d\n", color, r, g, b);
    
    uint32_t combined = combine_rgb(r, g, b);
    printf("重新组合: 0x%08X\n", combined & 0xFFFFFF);
    
    uint8_t gray = rgb_to_grayscale(r, g, b);
    printf("灰度值: %d\n", gray);
    printf("\n");
}

void performance_comparison() {
    printf("=== 性能比较测试 ===\n");
    const int iterations = 10000000;
    uint32_t test_val = 0x12345678;
    
    clock_t start, end;
    
    // 测试位计数性能
    start = clock();
    for (int i = 0; i < iterations; i++) {
        count_set_bits_kernighan(test_val);
    }
    end = clock();
    printf("Kernighan位计数: %f 秒\n", ((double)(end - start)) / CLOCKS_PER_SEC);
    
    
    start = clock();
    for (int i = 0; i < iterations; i++) {
        count_set_bits_lookup(test_val);
    }
    end = clock();
    printf("查表位计数: %f 秒\n", ((double)(end - start)) / CLOCKS_PER_SEC);
    printf("\n");
}

int main() {
    printf("NVIDIA 面试题：位操作和XOR技巧大全\n");
    printf("=====================================\n\n");
    
    test_basic_bit_operations();
    test_bit_position_finding();      // 新增位位置查找测试
    test_kernel_style_round_up();
    test_xor_tricks();
    demonstrate_xor_list();           // 新增XOR链表演示
    test_bit_counting();
    test_branchless_programming();
    test_fast_math();
    test_color_operations();
    performance_comparison();
    
    return 0;
}

/*
 * ================================================================================
 * 面试要点总结：
 * 
 * 1. 位操作基础：
 *    - 理解二进制表示和位运算符
 *    - 掌握基本的位设置、清除、翻转、检测操作
 *    - 了解位掩码和位域的使用
 * 
 * 2. XOR的特殊性质：
 *    - 自反性：a ^ a = 0
 *    - 恒等性：a ^ 0 = a
 *    - 交换律：a ^ b = b ^ a
 *    - 结合律：(a ^ b) ^ c = a ^ (b ^ c)
 * 
 * 3. 性能优化技巧：
 *    - 位操作比算术操作更快
 *    - 无分支编程避免分支预测失败
 *    - 查表法用空间换时间
 *    - 并行计算减少循环次数
 * 
 * 4. 实际应用场景：
 *    - 图形处理：颜色操作、像素处理
 *    - 游戏开发：碰撞检测、状态管理
 *    - 加密算法：XOR加密、哈希函数
 *    - 嵌入式系统：寄存器操作、内存优化
 * 
 * 5. 常见面试问题：
 *    - 如何交换两个变量而不使用临时变量？
 *    - 如何找出数组中唯一出现的数字？
 *    - 如何快速计算2的幂？
 *    - 如何实现无分支的条件语句？
 *    - 如何优化位计数操作？
 * 
 * 6. 高级技巧：
 *    - Morton编码用于空间索引
 *    - 位向量用于集合操作
 *    - SIMD指令的位操作应用
 *    - GPU编程中的位操作优化
 * 
 * 7. 注意事项：
 *    - 移位操作的未定义行为
 *    - 有符号数的右移实现相关性
 *    - 不同平台的字节序问题
 *    - 编译器优化对位操作的影响
 * ================================================================================
 */
